<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>轻舞飞扬</title>
  
  <subtitle>心有猛虎 细嗅蔷薇</subtitle>
  <link href="http://yoursite.com/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2022-10-22T01:34:44.326Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>FateZeros</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用 JavaScript 设计模式</title>
    <link href="http://yoursite.com/2021/08/10/2021-08-10/"/>
    <id>http://yoursite.com/2021/08/10/2021-08-10/</id>
    <published>2021-08-09T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-设计模式"><a href="#JavaScript-设计模式" class="headerlink" title="JavaScript 设计模式"></a>JavaScript 设计模式</h1><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。</p><h2 id="设计模式原则"><a href="#设计模式原则" class="headerlink" title="设计模式原则"></a>设计模式原则</h2><h3 id="S-–-Single-Responsibility-Principle-单一职责原则"><a href="#S-–-Single-Responsibility-Principle-单一职责原则" class="headerlink" title="S – Single Responsibility Principle 单一职责原则"></a>S – Single Responsibility Principle 单一职责原则</h3><p>1.一个程序只做好一件事<br>2.如果功能过于复杂就拆分开，每个部分保持独立</p><h3 id="O-–-OpenClosed-Principle-开放-封闭原则"><a href="#O-–-OpenClosed-Principle-开放-封闭原则" class="headerlink" title="O – OpenClosed Principle 开放/封闭原则"></a>O – OpenClosed Principle 开放/封闭原则</h3><p>1.对扩展开放，对修改封闭<br>2.增加需求时，扩展新代码，而非修改已有代码</p><h3 id="L-–-Liskov-Substitution-Principle-里氏替换原则"><a href="#L-–-Liskov-Substitution-Principle-里氏替换原则" class="headerlink" title="L – Liskov Substitution Principle 里氏替换原则"></a>L – Liskov Substitution Principle 里氏替换原则</h3><p>1.子类能覆盖父类<br>2.父类能出现的地方子类就能出现</p><h3 id="I-–-Interface-Segregation-Principle-接口隔离原则"><a href="#I-–-Interface-Segregation-Principle-接口隔离原则" class="headerlink" title="I – Interface Segregation Principle 接口隔离原则"></a>I – Interface Segregation Principle 接口隔离原则</h3><p>1.保持接口的单一独立</p><h3 id="D-–-Dependency-Inversion-Principle-依赖倒转原则"><a href="#D-–-Dependency-Inversion-Principle-依赖倒转原则" class="headerlink" title="D – Dependency Inversion Principle 依赖倒转原则"></a>D – Dependency Inversion Principle 依赖倒转原则</h3><p>1.面向接口编程，依赖于抽象而不依赖于具体</p><h2 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h2><h3 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h3><h4 id="1-单例模式"><a href="#1-单例模式" class="headerlink" title="1.单例模式"></a>1.单例模式</h4><p><Strong>一个类只有一个实例，并提供一个访问它的全局访问点</Strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class LoginForm &#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span></span>() &#123;</span><br><span class="line">    this.state = <span class="string">&#x27;hide&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">show</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;show&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">hide</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;hide&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">LoginForm.getInstance = (<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> instance</span><br><span class="line">  <span class="built_in">return</span> <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span>(!instance) &#123;</span><br><span class="line">      instance = new LoginForm()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> instance</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> obj1 = LoginForm.getInstance()</span><br><span class="line"><span class="built_in">let</span> obj2 = LoginForm.getInstance()</span><br><span class="line">console.log(obj1 === obj2)</span><br></pre></td></tr></table></figure><p><strong>优点</strong><br>1.划分命名空间，减少全局变量<br>2.增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护<br>3.且只会实例化一次。简化了代码的调试和维护</p><p><strong>缺点</strong><br>单一访问点，有可能导致模块强耦合。</p><p><strong>场景例子</strong><br>vuex 和 redux 中的 store</p><span id="more"></span><h4 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2.工厂模式"></a>2.工厂模式</h4><p><strong>工厂模式定义一个用于创建对象的接口，这个接口由子类决定实例化哪一个类</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Product &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">init</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;init&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Factory &#123;</span><br><span class="line">  create(name) &#123;</span><br><span class="line">    <span class="built_in">return</span> new Product(name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const factory = new Factory()</span><br><span class="line">const p = factory.create(<span class="string">&#x27;name1&#x27;</span>)</span><br><span class="line">p.init()</span><br></pre></td></tr></table></figure><p><strong>优点</strong><br>可以不让子系统与较大的对象之间形成强耦合。<br>创建对象的过程很复杂，但是只注意关心结果。<br>构造函数和创建者分离, 符合“开闭原则”。</p><p><strong>缺点</strong><br>单一访问点，有可能导致模块强耦合。</p><h3 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h3><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844904032826294286#heading-5">JavaScript 23种设计模式</a><br>[JavaScript 常用的设计模式](JavaScript 的一些常用设计模式)<br><a href="https://juejin.cn/post/6987180860852142093">webpack</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JavaScript-设计模式&quot;&gt;&lt;a href=&quot;#JavaScript-设计模式&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 设计模式&quot;&gt;&lt;/a&gt;JavaScript 设计模式&lt;/h1&gt;&lt;p&gt;设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。&lt;/p&gt;
&lt;h2 id=&quot;设计模式原则&quot;&gt;&lt;a href=&quot;#设计模式原则&quot; class=&quot;headerlink&quot; title=&quot;设计模式原则&quot;&gt;&lt;/a&gt;设计模式原则&lt;/h2&gt;&lt;h3 id=&quot;S-–-Single-Responsibility-Principle-单一职责原则&quot;&gt;&lt;a href=&quot;#S-–-Single-Responsibility-Principle-单一职责原则&quot; class=&quot;headerlink&quot; title=&quot;S – Single Responsibility Principle 单一职责原则&quot;&gt;&lt;/a&gt;S – Single Responsibility Principle 单一职责原则&lt;/h3&gt;&lt;p&gt;1.一个程序只做好一件事&lt;br&gt;2.如果功能过于复杂就拆分开，每个部分保持独立&lt;/p&gt;
&lt;h3 id=&quot;O-–-OpenClosed-Principle-开放-封闭原则&quot;&gt;&lt;a href=&quot;#O-–-OpenClosed-Principle-开放-封闭原则&quot; class=&quot;headerlink&quot; title=&quot;O – OpenClosed Principle 开放/封闭原则&quot;&gt;&lt;/a&gt;O – OpenClosed Principle 开放/封闭原则&lt;/h3&gt;&lt;p&gt;1.对扩展开放，对修改封闭&lt;br&gt;2.增加需求时，扩展新代码，而非修改已有代码&lt;/p&gt;
&lt;h3 id=&quot;L-–-Liskov-Substitution-Principle-里氏替换原则&quot;&gt;&lt;a href=&quot;#L-–-Liskov-Substitution-Principle-里氏替换原则&quot; class=&quot;headerlink&quot; title=&quot;L – Liskov Substitution Principle 里氏替换原则&quot;&gt;&lt;/a&gt;L – Liskov Substitution Principle 里氏替换原则&lt;/h3&gt;&lt;p&gt;1.子类能覆盖父类&lt;br&gt;2.父类能出现的地方子类就能出现&lt;/p&gt;
&lt;h3 id=&quot;I-–-Interface-Segregation-Principle-接口隔离原则&quot;&gt;&lt;a href=&quot;#I-–-Interface-Segregation-Principle-接口隔离原则&quot; class=&quot;headerlink&quot; title=&quot;I – Interface Segregation Principle 接口隔离原则&quot;&gt;&lt;/a&gt;I – Interface Segregation Principle 接口隔离原则&lt;/h3&gt;&lt;p&gt;1.保持接口的单一独立&lt;/p&gt;
&lt;h3 id=&quot;D-–-Dependency-Inversion-Principle-依赖倒转原则&quot;&gt;&lt;a href=&quot;#D-–-Dependency-Inversion-Principle-依赖倒转原则&quot; class=&quot;headerlink&quot; title=&quot;D – Dependency Inversion Principle 依赖倒转原则&quot;&gt;&lt;/a&gt;D – Dependency Inversion Principle 依赖倒转原则&lt;/h3&gt;&lt;p&gt;1.面向接口编程，依赖于抽象而不依赖于具体&lt;/p&gt;
&lt;h2 id=&quot;设计模式&quot;&gt;&lt;a href=&quot;#设计模式&quot; class=&quot;headerlink&quot; title=&quot;设计模式&quot;&gt;&lt;/a&gt;设计模式&lt;/h2&gt;&lt;h3 id=&quot;创建型&quot;&gt;&lt;a href=&quot;#创建型&quot; class=&quot;headerlink&quot; title=&quot;创建型&quot;&gt;&lt;/a&gt;创建型&lt;/h3&gt;&lt;h4 id=&quot;1-单例模式&quot;&gt;&lt;a href=&quot;#1-单例模式&quot; class=&quot;headerlink&quot; title=&quot;1.单例模式&quot;&gt;&lt;/a&gt;1.单例模式&lt;/h4&gt;&lt;p&gt;&lt;Strong&gt;一个类只有一个实例，并提供一个访问它的全局访问点&lt;/Strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class LoginForm &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;constructor&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.state = &lt;span class=&quot;string&quot;&gt;&amp;#x27;hide&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;show&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(&lt;span class=&quot;string&quot;&gt;&amp;#x27;show&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;hide&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(&lt;span class=&quot;string&quot;&gt;&amp;#x27;hide&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;LoginForm.getInstance = (&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; instance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;keyword&quot;&gt;if&lt;/span&gt;(!instance) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      instance = new LoginForm()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; instance&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; obj1 = LoginForm.getInstance()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;let&lt;/span&gt; obj2 = LoginForm.getInstance()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(obj1 === obj2)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;&lt;strong&gt;优点&lt;/strong&gt;&lt;br&gt;1.划分命名空间，减少全局变量&lt;br&gt;2.增强模块性，把自己的代码组织在一个全局变量名下，放在单一位置，便于维护&lt;br&gt;3.且只会实例化一次。简化了代码的调试和维护&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;缺点&lt;/strong&gt;&lt;br&gt;单一访问点，有可能导致模块强耦合。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;场景例子&lt;/strong&gt;&lt;br&gt;vuex 和 redux 中的 store&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue Diff 算法</title>
    <link href="http://yoursite.com/2021/07/31/2021-07-31/"/>
    <id>http://yoursite.com/2021/07/31/2021-07-31/</id>
    <published>2021-07-30T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.326Z</updated>
    
    <content type="html"><![CDATA[<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6994959998283907102">15 张图弄清楚 Vue2.0 Diff 算法</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;参考&quot;&gt;&lt;a href=&quot;#参考&quot; class=&quot;headerlink&quot; title=&quot;参考&quot;&gt;&lt;/a&gt;参考&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://juejin.cn/post/6994959998283907102&quot;&gt;15 张图弄清楚 Vue2.0 D</summary>
      
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>React Diff 算法</title>
    <link href="http://yoursite.com/2021/07/31/2021-08-05/"/>
    <id>http://yoursite.com/2021/07/31/2021-08-05/</id>
    <published>2021-07-30T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.326Z</updated>
    
    
    
    
    <category term="React" scheme="http://yoursite.com/categories/React/"/>
    
    
    <category term="React" scheme="http://yoursite.com/tags/React/"/>
    
  </entry>
  
  <entry>
    <title>Http 协议简析</title>
    <link href="http://yoursite.com/2021/07/25/2021-07-25/"/>
    <id>http://yoursite.com/2021/07/25/2021-07-25/</id>
    <published>2021-07-24T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Http-协议简析"><a href="#Http-协议简析" class="headerlink" title="Http 协议简析"></a>Http 协议简析</h1><p>Http/0.9 是于 1991 年提出，用来网络之间传递 HTML 超文本的内容，所以被称为<strong>超文本传输协议</strong></p><h2 id="Http-0-9-完整的请求流程"><a href="#Http-0-9-完整的请求流程" class="headerlink" title="Http/0.9 完整的请求流程"></a>Http/0.9 完整的请求流程</h2><p>1.Http 是基于 TCP 协议的，客户端要先根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议协议三次握手的过程。<br>2.建立好连接后，会发送一个 GET 请求行的信息，如GET/index.html 来获取 index.html<br>3.服务器接受到请求后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。<br>4.HTML 文档传输完成后，断开连接。</p><p><img src="/images/20210725/3.png"></p><h3 id="TCP-协议三次握手流程"><a href="#TCP-协议三次握手流程" class="headerlink" title="TCP 协议三次握手流程"></a>TCP 协议三次握手流程</h3><p>所谓的三次握手(Three-way HandShake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发3个包。<br>三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。</p><p>1.第一次握手(SYN=1，seq=x)<br>客户端发送一个 TCP 的 SYN 标志为 1 的包，指明客户端打算连接的服务器的端口，以及初始序号 X，保存在包头的序列号(Sequence Number)字段里</p><p>2.第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)</p><p>服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即 X+1。</p><p>3.第三次握手(ACK=1，ACKnum=y+1)<br>客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1。</p><p>当服务器端接收到第3次握手的包后，TCP握手结束。开始传输数据。</p><p><img src="/images/20210725/2.png"></p><span id="more"></span><h3 id="TCP-协议四次挥手流程"><a href="#TCP-协议四次挥手流程" class="headerlink" title="TCP 协议四次挥手流程"></a>TCP 协议四次挥手流程</h3><p>TCP 的连接的断开需要发送四个包，因此称为四次挥手(Four-way handshake)，也叫做改进的三次握手。客户端或服务器均可主动发起挥手动作。</p><p>1.第一次挥手(FIN=1，seq=x)<br>假设客户端想要关闭连接，客户端发送一个 FIN 标志为 1 的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。<br>发送完毕后，客户端进入 FIN_WAIT_1 状态。</p><p>2.第二次挥手(ACK=1，ACKnum=x+1)<br>服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。<br>发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。</p><p>3.第三次挥手(FIN=1，seq=y)<br>服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。<br>发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK</p><p>4.第四次挥手(ACK=1，ACKnum=y+1)<br>客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。<br>服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态</p><h2 id="Http-1-0"><a href="#Http-1-0" class="headerlink" title="Http/1.0"></a>Http/1.0</h2><p>1.新增请求头字段</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Accept 文件类型</span><br><span class="line">Accept-Encoding 压缩格式</span><br><span class="line">Accept-Charset 字符编码格式</span><br><span class="line">Accept-Language 国际化语音</span><br><span class="line">User-Agent 用于服务器统计客户端信息</span><br></pre></td></tr></table></figure><p>2.新增响应头</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Content-Encoding 服务器返回文件的压缩类型</span><br><span class="line">Content-Type 服务器返回的文件类型</span><br></pre></td></tr></table></figure><p>3.响应行状态码 <code>Status Code</code><br>status code: 200 表示请求成功</p><p>4.新增缓存机制，用来缓存已经下载过的资源，减轻了服务端压力</p><h2 id="Http-1-1"><a href="#Http-1-1" class="headerlink" title="Http/1.1"></a>Http/1.1</h2><p>Http/1.0 发送多个同域名请求。<strong>每次请求都需要重新建立 TCP 连接和断开连接的操作，这无疑增加了网络开销，同时也延迟了页面显示</strong><br><img src="/images/20210725/4.png"></p><p><strong>在 Http/1.1 请求头中增加了 Connection 字段，用于提供 TCP 的持久连接。</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Connection: keep-alive</span><br></pre></td></tr></table></figure><p>它默认是开启持久连接的，即对于同一个域名，浏览器默认支持 6 个 TCP 持久连接。建立一次 TCP 连接，可以发送多次 HTTP 请求。</p><p>Http/1.1 通过引入 Chunk transfer 机制来支持动态内容：服务器会将数据分割成若干个任意大小的数据块，每个数据块发送时会附上上个数据块的长度，最后使用一个零长度的块作为发送数据完成的标志。</p><p>Http/1.1 还引入了客户端 Cookie 机制和安全机制</p><h2 id="Http-2"><a href="#Http-2" class="headerlink" title="Http/2"></a>Http/2</h2><p>Http/1.1 尽管作出很多优化，但对带宽的利用率并不理想。<br><strong>带宽是指每秒最大能发送或者接收的字节数。我们把每秒能发送的最大字节数称为上行带宽，每秒能够接收的最大字节数称为下行带宽。</strong></p><p>Http/1.1 很难将带宽用满。主要由3个问题导致：</p><p>1.TCP 慢启动<br>一旦一个 TCP 连接建立之后，就进入了发送数据状态，刚开始 TCP 协议会采用一个非常慢的速度去发送数据，然后慢慢加快发送数据的速度，直到发送数据的速度达到一个理想状态，我们把这个过程称为慢启动。</p><p>2.同时开启多条 TCP 连接，这些连接会竞争固定的带宽。</p><p>3.HTTP/1.1 队头阻塞的问题<br>HTTP/1.1 中使用持久连接时，虽然能公用一个 TCP 管道，但是在一个管道中同一时刻只能处理一个请求，在当前的请求没有结束之前，其他的请求只能处于阻塞状态。这意味着我们不能随意在一个管道中发送请求和接收内容。</p><p>为了解决 Http/1.1 中的问题，<strong>Http/2 采用多路复用的机制。</strong></p><h3 id="Http-2-多路复用"><a href="#Http-2-多路复用" class="headerlink" title="Http/2 多路复用"></a>Http/2 多路复用</h3><p>浏览器针对同一域名的资源，只建立一个 TCP 连接通道，所有的针对这个域名的请求全部都在这个通道中完成。</p><p>数据的传输不再使用文本格式，而是会将它们分割为更小的流和帧，并对他们采用二进制格式的编码。在一个 TCP 连接通道中，支持任意数量的双向数据流，这些数据流是并行、乱序的且它们之间互不干扰。而数据流中传输的数据是二进制帧，它是 Http/2 中数据传输的最小单位，一个流中的帧是按照顺序传输的，且是并行的，所以无需按顺序等待。</p><p><img src="/images/20210725/5.png"></p><p><strong>Http/2 因为只使用一个 TCP 连接，所以减少了由于 TCP 慢启动而消耗的时间，另外也由于只有单条 TCP 连接，所以不存在不同的 TCP 争夺网络带宽的问题</strong></p><p>客户端发送的请求经过二进制分帧层后，不再是一个个完整的 HTTP 请求报文，而是一堆乱序的帧（即不同流的帧是乱的，但是同一条流的帧数顺序传输的），所以就不会按顺序传输，也就不存在等待，从而解决了 HTTP 对头阻塞问题。</p><p><strong>Http/2 其他特性</strong></p><p>1.可以设置请求的优先级<br>支持设置请求的优先级，这样服务器收到高优先级的请求后，会优先处理。</p><p>2.服务器推送<br>在 HTTP/2 中服务器解析到一个 HTML 页面后，服务器知道浏览器需要这个页面上引用到的资源，比如 CSS 和 JS，那么服务器就会主动的把这些资源一并推送给浏览器，减少客户端的等待时间。</p><p>3.头部压缩<br>HTTP/2 使用 HPACK 压缩算法对请求头和响应头进行压缩。</p><h2 id="Http-缓存"><a href="#Http-缓存" class="headerlink" title="Http 缓存"></a>Http 缓存</h2><p>浏览器缓存指的就是浏览器对之前请求过的文件进行缓存，以便在下一次访问时重复使用，从而节省带宽、提升访问速度、降低服务器压力。</p><p>HTTP 缓存机制就是利用HTTP响应头将所请求的资源在浏览器中进行缓存，缓存方式主要分为两种：强缓存、协商缓存。</p><h3 id="Http-强缓存"><a href="#Http-强缓存" class="headerlink" title="Http 强缓存"></a>Http 强缓存</h3><p>强缓存是指在缓存期间不会向服务器发起请求，只有过期后才会想服务器发起请求。</p><p>1.Expires</p><p><code>Expires</code> 是 <code>http1.0</code> 中的字段，是一个绝对时间，即服务器时间。浏览器检查当前时间，如果还没到失效时间就直接使用缓存文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;Expires&quot;</span> content=<span class="string">&quot;0&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p>2.Cache-Control</p><p>由于 <code>Expires</code> 存在服务器时间与客户端时间不一致的问题，所以 <code>http1.1</code> 中新增了 <code>Cache-Control</code> 字段。<br>通过设置 <code>max-age</code> 来保存一个相对时间，表示其在该相对时间内容有效。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta http-equiv=<span class="string">&quot;Cache-Control&quot;</span> content=<span class="string">&quot;no-cache&quot;</span> /&gt;</span><br></pre></td></tr></table></figure><p><code>content</code> 可以设置为:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private: 默认值，表示客户端可以缓存，中间代理、CDN等不能缓存此响应</span><br><span class="line">public: 表示客户端和代理服务器都可缓存</span><br><span class="line">max-age=xxx: 缓存的内容将在xxx秒后失效</span><br><span class="line">no-cache: 需要使用协商缓存来验证缓存数据</span><br><span class="line">no-store: 所有内容都不会缓存（包括协商缓存），每次都向服务器请求最新资源</span><br><span class="line">must-revalidate: 在缓存过期前可以使用，过期后必须向服务器验证</span><br></pre></td></tr></table></figure><p><strong>当同时设置 Expires 和 Cache-Control 时，浏览器会优先使用 Cache-Control</strong></p><h3 id="Http-协商缓存"><a href="#Http-协商缓存" class="headerlink" title="Http 协商缓存"></a>Http 协商缓存</h3><p>协商缓存都会向服务器发送请求，判断缓存数据是否过期，过期的话会返回新的内容，没有过期则使用本地的缓存数据。</p><p><img src="/images/20210725/1.png"></p><p>1.Last-Modify</p><p><code>Last-modified</code> 是 <code>http1.0</code> 中的字段，是第一次请求资源时，服务器返回的字段，表示最后一次更新的时间。下一次浏览器请求资源时就发送 <code>if-modified-since</code> 字段。服务器用本地 <code>Last-modified</code>时间与 <code>if-modified-since</code> 时间比较，如果不一致则认为缓存已过期并返回新资源给浏览器；如果时间一致则发送 304 状态码，让浏览器继续使用缓存。</p><p>2.Etag</p><p><code>Etag</code>是 <code>http1.1</code> 中新增的字段，是资源的实体标识（哈希字符串），当资源内容更新时，<code>Etag</code> 会改变。服务器会判断 Etag 是否发生变化，如果变化则返回新资源，否则返回304。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/lWWnVGxDN8KWsGaohq58Rw">一文了解 Http 发展史</a><br><a href="https://mp.weixin.qq.com/s?__biz=MzIxMjExNzQxMQ==&mid=2247485633&idx=1&sn=ce74e76b58274934d23f1b416c05bf95&chksm=974bba0da03c331b7cf2e2e17104bc20e69a1f1c373ad759c2211c3ae1a2c7e81cb524964c82&mpshare=1&scene=23&srcid=0804twhVu5AuymNJx10Ywkxn&sharer_sharetime=1628037166143&sharer_shareid=bf7a7143f255060150499be3bd42eb7d%23rd">http 缓存</a><br><a href="https://hit-alibaba.github.io/interview/basic/network/TCP.html">TCP 三次握手，四次挥手</a><br><a href="https://juejin.cn/post/6994062019754197005">Http 强缓存</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Http-协议简析&quot;&gt;&lt;a href=&quot;#Http-协议简析&quot; class=&quot;headerlink&quot; title=&quot;Http 协议简析&quot;&gt;&lt;/a&gt;Http 协议简析&lt;/h1&gt;&lt;p&gt;Http/0.9 是于 1991 年提出，用来网络之间传递 HTML 超文本的内容，所以被称为&lt;strong&gt;超文本传输协议&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;Http-0-9-完整的请求流程&quot;&gt;&lt;a href=&quot;#Http-0-9-完整的请求流程&quot; class=&quot;headerlink&quot; title=&quot;Http/0.9 完整的请求流程&quot;&gt;&lt;/a&gt;Http/0.9 完整的请求流程&lt;/h2&gt;&lt;p&gt;1.Http 是基于 TCP 协议的，客户端要先根据 IP 地址、端口和服务器建立 TCP 连接，而建立连接的过程就是 TCP 协议协议三次握手的过程。&lt;br&gt;2.建立好连接后，会发送一个 GET 请求行的信息，如GET/index.html 来获取 index.html&lt;br&gt;3.服务器接受到请求后，读取对应的 HTML 文件，并将数据以 ASCII 字符流返回给客户端。&lt;br&gt;4.HTML 文档传输完成后，断开连接。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/20210725/3.png&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;TCP-协议三次握手流程&quot;&gt;&lt;a href=&quot;#TCP-协议三次握手流程&quot; class=&quot;headerlink&quot; title=&quot;TCP 协议三次握手流程&quot;&gt;&lt;/a&gt;TCP 协议三次握手流程&lt;/h3&gt;&lt;p&gt;所谓的三次握手(Three-way HandShake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发3个包。&lt;br&gt;三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。&lt;/p&gt;
&lt;p&gt;1.第一次握手(SYN=1，seq=x)&lt;br&gt;客户端发送一个 TCP 的 SYN 标志为 1 的包，指明客户端打算连接的服务器的端口，以及初始序号 X，保存在包头的序列号(Sequence Number)字段里&lt;/p&gt;
&lt;p&gt;2.第二次握手(SYN=1, ACK=1, seq=y, ACKnum=x+1)&lt;/p&gt;
&lt;p&gt;服务器发回确认包(ACK)应答。即 SYN 标志位和 ACK 标志位均为1。服务器端选择自己 ISN 序列号，放到 Seq 域里，同时将确认序号(Acknowledgement Number)设置为客户的 ISN 加1，即 X+1。&lt;/p&gt;
&lt;p&gt;3.第三次握手(ACK=1，ACKnum=y+1)&lt;br&gt;客户端再次发送确认包(ACK)，SYN 标志位为0，ACK 标志位为1，并且把服务器发来 ACK 的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1。&lt;/p&gt;
&lt;p&gt;当服务器端接收到第3次握手的包后，TCP握手结束。开始传输数据。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/20210725/2.png&quot;&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Http" scheme="http://yoursite.com/categories/Http/"/>
    
    
    <category term="Http" scheme="http://yoursite.com/tags/Http/"/>
    
  </entry>
  
  <entry>
    <title>在 centos 服务器上运行 docker 容器</title>
    <link href="http://yoursite.com/2021/07/19/2021-07-18/"/>
    <id>http://yoursite.com/2021/07/19/2021-07-18/</id>
    <published>2021-07-18T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="在-centos-服务器上运行-docker-容器"><a href="#在-centos-服务器上运行-docker-容器" class="headerlink" title="在 centos 服务器上运行 docker 容器"></a>在 centos 服务器上运行 docker 容器</h1><p>在本地打包好镜像后，并且导出 docker 容器。</p><h2 id="在-centos-上安装-Docker"><a href="#在-centos-上安装-Docker" class="headerlink" title="在 centos 上安装 Docker"></a>在 centos 上安装 Docker</h2><p>首先更新您的系统软件包并安装所需的依赖项</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo yum install yum-utils device-mapper-persistent-data lvm2</span><br></pre></td></tr></table></figure><p>将 Docker 稳定存储库添加到系统</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure><p>使用yum，安装最新版本的 Docker CE</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo yum install docker-ce</span><br></pre></td></tr></table></figure><p>安装 Docker 软件包后，启动 Docker 守护程序并使其在启动时自动启动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 开启 dokcer</span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker</span><br><span class="line"></span><br><span class="line">// 重启 docker</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>验证 Docker 服务正在运行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status docker</span><br></pre></td></tr></table></figure><p>查看 docker 版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="导出镜像并上传到-centos-服务器"><a href="#导出镜像并上传到-centos-服务器" class="headerlink" title="导出镜像并上传到 centos 服务器"></a>导出镜像并上传到 centos 服务器</h2><p>docker 导入导出 tar 包</p><h3 id="docker-export-import"><a href="#docker-export-import" class="headerlink" title="docker export/import"></a>docker export/import</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 查看镜像</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line">// <span class="built_in">export</span>/import 导出导入镜像</span><br><span class="line">docker <span class="built_in">export</span> &lt;镜像<span class="built_in">id</span>&gt; &gt; &lt;镜像&gt;.tar</span><br><span class="line">docker import - &lt;镜像名&gt; &lt; &lt;镜像&gt;.tar</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="docker-save-load"><a href="#docker-save-load" class="headerlink" title="docker save/load"></a>docker save/load</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 查看镜像</span><br><span class="line">docker images</span><br><span class="line"></span><br><span class="line">// save</span><br><span class="line">docker save -o &lt;镜像&gt;.tar &lt;镜像<span class="built_in">id</span>&gt;</span><br><span class="line"></span><br><span class="line">// load</span><br><span class="line">docker load -i &lt;镜像&gt;.tar</span><br></pre></td></tr></table></figure><p>上传到服务器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scp -P 22 -r &lt;容器&gt;.tar 用户名@ip:/root/../usr/local/文件夹名</span><br></pre></td></tr></table></figure><p>docker 运行容器<br>在 centos 环境下 <strong>import 镜像时，docker run 导入的镜像必须带 command</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// import 镜像run</span><br><span class="line">docker run -itd --name &lt;容器命名&gt; -p 2211:80 &lt;镜像<span class="built_in">id</span>&gt; <span class="built_in">command</span>[/bin/bash]</span><br><span class="line"></span><br><span class="line">// load</span><br><span class="line">docker run -itd --name &lt;容器命名&gt; -p 2211:80 &lt;镜像<span class="built_in">id</span>&gt; </span><br></pre></td></tr></table></figure><p>查看运行的容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>docker 容器运行成功后，查看容器 IP：<code>docker inspect &lt;容器id&gt; |grep IPAddress</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 查看容器网络是否联通</span><br><span class="line">ping &lt;容器IP&gt;</span><br><span class="line"></span><br><span class="line">curl &lt;容器IP&gt;:&lt;容器暴露端口&gt;</span><br></pre></td></tr></table></figure><p>以上都没问题，则表示容器部署成功</p><h2 id="docker-的网络模式"><a href="#docker-的网络模式" class="headerlink" title="docker 的网络模式"></a>docker 的网络模式</h2><h3 id="Bridge-模式-–net-bridge（默认）"><a href="#Bridge-模式-–net-bridge（默认）" class="headerlink" title="Bridge 模式  –net=bridge（默认）"></a>Bridge 模式  –net=bridge（默认）</h3><p>在 centos 服务器安装 docker 环境后，会在宿主机安装一个虚拟网桥 <code>docker0</code>。可以使用宿主机在 <code>docker0</code> 上的 IP 地址来代替 localhost</p><p>通过 <code>ip addr</code> 命令可以看到虚拟网桥 <code>docker0</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 查看宿主机网络</span><br><span class="line">ip addr</span><br><span class="line"></span><br><span class="line">// 查看容器 port</span><br><span class="line">docker port 42a00eadd01e</span><br><span class="line"></span><br><span class="line">// 查看容器的网关地址</span><br><span class="line">docker inspect 42a00eadd01e | grep IPAddress</span><br></pre></td></tr></table></figure><p>基于对 net namespace 的控制，docker可以为在容器创建隔离的网络环境，在隔离的网络环境下，容器具有完全独立的网络栈，与宿主机隔离，也可以使容器共享主机或者其他容器的网络命名空间。</p><p>容器通过DHCP获取一个与 docker0 同网段的 IP 地址，并默认连接到 docker0 网桥，以此实现容器与宿主机的网络互通</p><h3 id="Host-模式-–net-host"><a href="#Host-模式-–net-host" class="headerlink" title="Host 模式 –net=host"></a>Host 模式 –net=host</h3><p>直接使用容器宿主机的网络命名空间。<br>将不拥有自己独立的Network Namespace，即没有独立的网络环境。它使用宿主机的ip和端口。</p><h3 id="Container-模式-–net-container-指定容器名"><a href="#Container-模式-–net-container-指定容器名" class="headerlink" title="Container 模式  –net=container:指定容器名"></a>Container 模式  –net=container:指定容器名</h3><p>与 host 模式类似，只是容器将与指定的容器共享网络命名空间</p><h3 id="None模式-–net-none"><a href="#None模式-–net-none" class="headerlink" title="None模式 –net=none"></a>None模式 –net=none</h3><p>为容器创建独立网络命名空间，但不为它做任何网络配置，容器中只有 lo，用户可以在此基础上，对容器网络做任意定制。</p><h2 id="centos-上防火墙基本使用"><a href="#centos-上防火墙基本使用" class="headerlink" title="centos 上防火墙基本使用"></a>centos 上防火墙基本使用</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 查看所有打开的端口</span><br><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line"></span><br><span class="line">// 更新防火墙规则</span><br><span class="line">firewall-cmd --reload</span><br><span class="line"></span><br><span class="line">// 开启端口，成功开启后需要 reload</span><br><span class="line">firewall-cmd --zone=public --add-port=80/tcp --permanent  （--permanent永久生效，没有此参数重启后失效） <span class="comment">#开启80端口</span></span><br><span class="line"></span><br><span class="line">// 查看端口是否开启</span><br><span class="line">firewall-cmd --zone=public --query-port=80/tcp</span><br><span class="line"></span><br><span class="line">// 删除端口</span><br><span class="line">firewall-cmd --zone=public --remove-port=80/tcp --permanent <span class="comment">#删除80端口配置</span></span><br></pre></td></tr></table></figure><h2 id="docker-启动后映射的端口无法被访问问题"><a href="#docker-启动后映射的端口无法被访问问题" class="headerlink" title="docker 启动后映射的端口无法被访问问题"></a>docker 启动后映射的端口无法被访问问题</h2><h3 id="查看防火墙是否有映射端口号"><a href="#查看防火墙是否有映射端口号" class="headerlink" title="查看防火墙是否有映射端口号"></a>查看防火墙是否有映射端口号</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --list-ports</span><br><span class="line">firewall-cmd --zone=docker --list-ports</span><br></pre></td></tr></table></figure><p>添加策略对外打开指定的端口</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">firewall-cmd --zone=public --add-port=[端口号]/tcp --permanent</span><br><span class="line">firewall-cmd --reload</span><br></pre></td></tr></table></figure><h3 id="查看-ip-转发有没有打开"><a href="#查看-ip-转发有没有打开" class="headerlink" title="查看 ip 转发有没有打开"></a>查看 ip 转发有没有打开</h3><p>net.ipv4.ip_forward = 1 表示打开，为 0 则表示没打开</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">sysctl net.ipv4.ip_forward</span><br><span class="line">// <span class="built_in">echo</span> <span class="string">&#x27;net.ipv4.ip_forward = 1&#x27;</span> &gt;&gt; /etc/sysctl.conf</span><br><span class="line"></span><br><span class="line">// 网络重启</span><br><span class="line">systemctl restart network.service</span><br><span class="line"></span><br><span class="line">// 重启 docker 服务</span><br><span class="line">systemctl restart docker</span><br><span class="line"></span><br><span class="line">// </span><br><span class="line">iptables --list|grep docker</span><br></pre></td></tr></table></figure><h3 id="关闭-ipv6-监听"><a href="#关闭-ipv6-监听" class="headerlink" title="关闭 ipv6 监听"></a>关闭 ipv6 监听</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 查看服务器端口监听</span><br><span class="line">netstat -nptl</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.myfreax.com/how-to-install-and-use-docker-on-centos-7/">如何在 CentOS 7上安装和使用 Docker</a><br><a href="https://blog.csdn.net/Osumail/article/details/105966946">利用 docker 将 web 项目部署到服务器</a><br><a href="http://www.xinhuyun.com/help/post/1433.html">Linux 中 centos7 防火墙基本上使用</a><br><a href="https://blog.csdn.net/ithaibiantingsong/article/details/81386307">docker 网络模式</a><br><a href="https://juejin.cn/post/6868086876751085581">Docker 网络模式详解及容器间网络通信</a><br><a href="https://www.hangge.com/blog/cache/detail_2411.html">Docker 镜像 import 与 save 的区别</a><br><a href="https://www.jianshu.com/p/225d040d0b66">centos 上禁用 ipv6 监听</a><br><a href="https://www.cnblogs.com/dotnet261010/p/13283176.html">Docker 镜像 import 与 save 的区别2</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;在-centos-服务器上运行-docker-容器&quot;&gt;&lt;a href=&quot;#在-centos-服务器上运行-docker-容器&quot; class=&quot;headerlink&quot; title=&quot;在 centos 服务器上运行 docker 容器&quot;&gt;&lt;/a&gt;在 centos 服务器上运行 docker 容器&lt;/h1&gt;&lt;p&gt;在本地打包好镜像后，并且导出 docker 容器。&lt;/p&gt;
&lt;h2 id=&quot;在-centos-上安装-Docker&quot;&gt;&lt;a href=&quot;#在-centos-上安装-Docker&quot; class=&quot;headerlink&quot; title=&quot;在 centos 上安装 Docker&quot;&gt;&lt;/a&gt;在 centos 上安装 Docker&lt;/h2&gt;&lt;p&gt;首先更新您的系统软件包并安装所需的依赖项&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo yum update&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo yum install yum-utils device-mapper-persistent-data lvm2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;将 Docker 稳定存储库添加到系统&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;使用yum，安装最新版本的 Docker CE&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo yum install docker-ce&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;安装 Docker 软件包后，启动 Docker 守护程序并使其在启动时自动启动&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 开启 dokcer&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo systemctl start docker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo systemctl &lt;span class=&quot;built_in&quot;&gt;enable&lt;/span&gt; docker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 重启 docker&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;sudo systemctl restart docker&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;验证 Docker 服务正在运行&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;sudo systemctl status docker&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;查看 docker 版本&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker -v&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Docker 深入浅出</title>
    <link href="http://yoursite.com/2021/07/17/2021-07-17/"/>
    <id>http://yoursite.com/2021/07/17/2021-07-17/</id>
    <published>2021-07-16T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Docker-深入浅出"><a href="#Docker-深入浅出" class="headerlink" title="Docker 深入浅出"></a>Docker 深入浅出</h1><h2 id="什么是-Docker"><a href="#什么是-Docker" class="headerlink" title="什么是 Docker"></a>什么是 Docker</h2><p><a href="https://www.docker.com/">Docker 官网</a></p><p>在官网上下载安装成功后，使用 <code>docker -v</code> 可以查看 docker 版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker -v</span><br><span class="line"></span><br><span class="line">Docker version 20.10.7, build f0df350</span><br></pre></td></tr></table></figure><p>Docker 技术与传统虚拟化方式的区别<br><strong>传统的虚拟机技术是一套完整的操作系统和应用进程。</strong><br><strong>Docker 容器内的应用进程则是直接运行于宿主内核，容器没有自己的内核和硬件虚拟。</strong><br>Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。</p><p><img src="/images/20210717/1.png"></p><h2 id="使用-Docker-优势"><a href="#使用-Docker-优势" class="headerlink" title="使用 Docker 优势"></a>使用 Docker 优势</h2><p>1.提供一致的运行环境。<br>2.轻松的项目迁移。<br>3.快速部署与回滚。</p><span id="more"></span><h2 id="镜像与容器"><a href="#镜像与容器" class="headerlink" title="镜像与容器"></a>镜像与容器</h2><p>Docker 镜像(Image) 是一个特殊的文件系统，除了提供容器运行时所需的程序、库、资源、配置等文件外，还包含了一些为运行时准备的一些配置参数（如匿名卷、环境变量、用户等）。镜像不包含 任何动态数据，其内容在构建之后也不会被改变。</p><h3 id="分层存储"><a href="#分层存储" class="headerlink" title="分层存储"></a>分层存储</h3><p>Docker 镜像充分利用 <a href="https://en.wikipedia.org/wiki/Union_mount">Union FS</a> 的技术，将其设计为分层存储的架构。<br>镜像构建时，会一层层构建，前一层是后一层的基础。每一层构建完就不会再发生改变，后一层上的任何改变只发生在自己这一层。比如，删除前一层文件的操作，实际不是真的删除前一层的文件，而是仅在当前层标记为该文件已删除。在最终容器运行的时候，虽然不会看到这个文件，但是实际上该文件会一直跟随镜像。因此，在构建镜像的时候，需要额外小心，每一层尽量只包含该层需要添加的东西，任何额外的东西应该在该层构建结束前清理掉。</p><p>容器(Container) 是镜像运行时的实体。容器可以被创建、启动、停止、删除、暂停等。<br><strong>容器的实质是进程，但与直接在宿主执行的进程不同，容器进程运行于属于自己的独立的命名空间。</strong><br>容器内的进程是运行在一个隔离的环境里，使用起来，就好像是在一个独立于宿主的系统下操作一样。</p><h2 id="使用-Docker-镜像"><a href="#使用-Docker-镜像" class="headerlink" title="使用 Docker 镜像"></a>使用 Docker 镜像</h2><p><a href="https://hub.docker.com/search?q=&type=image">Docker HUB</a>上有很多可以使用的镜像。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker pull [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]</span><br><span class="line"></span><br><span class="line">docker pull ubuntu:18.04</span><br></pre></td></tr></table></figure><p>上述命令中没有给出 Docker 镜像仓库地址，因此将会从 Docker Hub （docker.io）获取镜像。即 docker.io/library/ubuntu:18.04。</p><h3 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h3><p>有了镜像以后，我们就能够以这个镜像为基础启动并运行一个容器。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">docker run -it --<span class="built_in">rm</span> [镜像名] bash</span><br><span class="line"></span><br><span class="line">docker <span class="built_in">exec</span> -it [镜像名] bash</span><br></pre></td></tr></table></figure><p><code>it</code>: 是两个参数，<code>-i</code>：交互操作，<code>-t</code> 终端。<br><code>rm</code>: 声明容器推出后随之将其删除。<br><code>bash</code>: 放在镜像名后的是命令。bash 则为 shell 交互式。</p><p>第二条命令则是以交互式终端的方式<strong>进入容器，修改内容</strong>，并以 <code>exit</code> 退出容器内部。</p><h3 id="列出镜像"><a href="#列出镜像" class="headerlink" title="列出镜像"></a>列出镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker images <span class="built_in">ls</span></span><br><span class="line">docker images |grep [镜像名]</span><br></pre></td></tr></table></figure><h3 id="删除镜像"><a href="#删除镜像" class="headerlink" title="删除镜像"></a>删除镜像</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker image <span class="built_in">rm</span> [选项] &lt;镜像1&gt;</span><br></pre></td></tr></table></figure><p>其中 <code>&lt;镜像&gt;</code> 可以是 <code>ID</code>，<code>镜像名</code>，<code>镜像摘要</code>。</p><p>Dockerfile 是一个文本文件，其内包含了一条条的指令(Instruction)，每一条指令构建一层，因此每一条指令的内容，就是描述该层应当如何构建。</p><h3 id="FROM-指令"><a href="#FROM-指令" class="headerlink" title="FROM 指令"></a>FROM 指令</h3><p>使用 <code>FROM</code> 指令指定基础镜像，必备指令，且是第一条指令。<br>在 Docker Hub 上有很多高质量的官方镜像，例如可以直接拿来使用的服务类镜像，如 <code>nginx</code>、<code>redis</code>、<code>mongo</code>、<code>mysql</code>、<code>tomcat</code>等</p><h3 id="RUN-指令"><a href="#RUN-指令" class="headerlink" title="RUN 指令"></a>RUN 指令</h3><p><code>RUN</code> 指令是用来执行命令的，常用的方式有两种</p><p>1.shell 格式 <code>RUN &lt;命令&gt;</code><br>2.exec 格式 <code>RUN [&#39;可执行文件&#39;, &#39;参数1&#39;, &#39;参数2&#39;...]</code></p><p>Dockerfile 中每一个指令都会建立一层，<code>RUN</code> 也不例外, 每一个 <code>RUN</code> 的行为，就和刚才我们手工建立镜像的过程一样：新建立一层，在其上执行这些命令，执行结束后，<code>commit</code> 这一层的修改，构成新的镜像</p><p>具体的 <a href="https://yeasy.gitbook.io/docker_practice/image/commit">commit 原理</a> 详解。</p><p><strong>Union FS 是有最大层数限制的。多个 <code>RUN</code> 指令可以使用 <code>&amp;&amp;</code> 将指令串联起来。这样就可以减少 <code>docker</code> 镜像层数。</strong></p><h3 id="其他指令"><a href="#其他指令" class="headerlink" title="其他指令"></a>其他指令</h3><p><a href="https://yeasy.gitbook.io/docker_practice/image/dockerfile">指令详解</a></p><p><code>COPY</code> 复制文件<br><code>ADD</code> 更高级的文件复制<br><code>EXPOSE</code> 暴露端口<br><code>WORKDIR</code> 指定工作目录</p><h2 id="docker-构建镜像"><a href="#docker-构建镜像" class="headerlink" title="docker 构建镜像"></a>docker 构建镜像</h2><p>在 <code>Dockerfile</code> 文件所在的目录执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker build [选项] &lt;上下文路径/URL/-&gt; </span><br></pre></td></tr></table></figure><p><a href="https://docs.docker.com/engine/reference/commandline/build/">docker build 选项参数</a></p><h3 id="镜像构建上下文-Context"><a href="#镜像构建上下文-Context" class="headerlink" title="镜像构建上下文(Context)"></a>镜像构建上下文(Context)</h3><p><code>docker build</code> 命令最后需要指定<strong>上下文路径</strong>。</p><p>在理解上下文路径的时候，我们需要理解 <code>docker build</code> 原理。<strong>Docker 在运行的时候分为 Docker 引擎(也就是服务端守护进程)和客户端工具。</strong><br>Docker 的引擎提供了一组 REST API，被称为 <a href="https://docs.docker.com/engine/api/sdk/">Docker Remote API</a>，而如 docker 命令这样的客户端工具，则是通过这组 API 与 Docker 引擎交互，从而完成各种功能。</p><p><strong>因此，虽然表面上我们好像是在本机执行各种 docker 功能，但实际上，一切都是使用的远程调用形式在服务端（Docker 引擎）完成。也因为这种 C/S 设计，让我们操作远程服务器的 Docker 引擎变得轻而易举。</strong></p><p>当我们进行镜像构建的时候，并非所有定制都会通过 <code>RUN</code> 指令完成，经常会需要将一些本地文件复制进镜像，比如通过 <code>COPY</code> 指令、<code>ADD</code> 指令等。而 docker build 命令构建镜像，其实并非在本地构建，<strong>而是在服务端，也就是 Docker 引擎中构建的。</strong></p><p>这就引入了上下文的概念。当构建的时候，用户会指定构建镜像上下文的路径，docker build 命令得知这个路径后，会将路径下的所有内容打包，然后上传给 Docker 引擎。这样 Docker 引擎收到这个上下文包后，展开就会获得构建镜像所需的一切文件。</p><p>当在 <code>Dockerfile</code> 中这么写的 </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">COPY ./package.json /app/</span><br></pre></td></tr></table></figure><p>这并不是要复制执行 docker build 命令所在的目录下的 package.json，也不是复制 Dockerfile 所在目录下的 package.json，而是复制<strong>上下文（context)</strong>目录下的 package.json。</p><p>一般来说，应该会将 Dockerfile 置于一个空目录下，或者项目根目录下。如果该目录下没有所需文件，那么应该把所需文件复制一份过来。如果目录下有些东西确实不希望构建时传给 Docker 引擎，那么可以用 .gitignore 一样的语法写一个 .dockerignore，该文件是用于剔除不需要作为上下文传递给 Docker 引擎的。</p><h2 id="导出-docker-容器"><a href="#导出-docker-容器" class="headerlink" title="导出 docker 容器"></a>导出 docker 容器</h2><p>在 <code>docker build</code> 生成镜像后，可以导出容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// run 镜像</span><br><span class="line">docker run &lt;镜像名&gt;</span><br><span class="line"></span><br><span class="line">// -d run container <span class="keyword">in</span> background and <span class="built_in">print</span> container ID</span><br><span class="line">// -p 本地的 80 端口映射到容器的 80 端口</span><br><span class="line">docker run -d -p 80:80 &lt;镜像名&gt;</span><br><span class="line"></span><br><span class="line">// 查看容器</span><br><span class="line">docker ps -a</span><br><span class="line"></span><br><span class="line">// 停止容器</span><br><span class="line">docker stop &lt;容器<span class="built_in">id</span>&gt;</span><br><span class="line"></span><br><span class="line">// 删除容器</span><br><span class="line">docker <span class="built_in">rm</span> &lt;容器<span class="built_in">id</span>&gt;</span><br><span class="line"></span><br><span class="line">// 导出容器</span><br><span class="line">docker <span class="built_in">export</span> &lt;容器名&gt; &gt; &lt;保存路径&gt;/[容器名].tar</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://docs.docker.com/engine/reference/commandline/build/">Docker API 文档</a><br><a href="https://yeasy.gitbook.io/docker_practice/introduction">Docker 从入门到实践</a><br><a href="https://segmentfault.com/a/1190000037762279">Docker 实战总结</a><br><a href="https://zhuanlan.zhihu.com/p/39241059">使用 Docker 构建前端应用</a><br><a href="https://www.runoob.com/docker/docker-dockerfile.html">docker-dockerfile</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Docker-深入浅出&quot;&gt;&lt;a href=&quot;#Docker-深入浅出&quot; class=&quot;headerlink&quot; title=&quot;Docker 深入浅出&quot;&gt;&lt;/a&gt;Docker 深入浅出&lt;/h1&gt;&lt;h2 id=&quot;什么是-Docker&quot;&gt;&lt;a href=&quot;#什么是-Docker&quot; class=&quot;headerlink&quot; title=&quot;什么是 Docker&quot;&gt;&lt;/a&gt;什么是 Docker&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://www.docker.com/&quot;&gt;Docker 官网&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在官网上下载安装成功后，使用 &lt;code&gt;docker -v&lt;/code&gt; 可以查看 docker 版本&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;docker -v&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Docker version 20.10.7, build f0df350&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;Docker 技术与传统虚拟化方式的区别&lt;br&gt;&lt;strong&gt;传统的虚拟机技术是一套完整的操作系统和应用进程。&lt;/strong&gt;&lt;br&gt;&lt;strong&gt;Docker 容器内的应用进程则是直接运行于宿主内核，容器没有自己的内核和硬件虚拟。&lt;/strong&gt;&lt;br&gt;Docker 在容器的基础上，进行了进一步的封装，从文件系统、网络互联到进程隔离等等，极大的简化了容器的创建和维护。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/20210717/1.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;使用-Docker-优势&quot;&gt;&lt;a href=&quot;#使用-Docker-优势&quot; class=&quot;headerlink&quot; title=&quot;使用 Docker 优势&quot;&gt;&lt;/a&gt;使用 Docker 优势&lt;/h2&gt;&lt;p&gt;1.提供一致的运行环境。&lt;br&gt;2.轻松的项目迁移。&lt;br&gt;3.快速部署与回滚。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://yoursite.com/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>Vue2.0 Options API 与 Vue3.0 Composition API 区别</title>
    <link href="http://yoursite.com/2021/07/15/2021-07-15/"/>
    <id>http://yoursite.com/2021/07/15/2021-07-15/</id>
    <published>2021-07-14T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue2-0-Options-API-与-Vue3-0-Composition-API-区别"><a href="#Vue2-0-Options-API-与-Vue3-0-Composition-API-区别" class="headerlink" title="Vue2.0 Options API 与 Vue3.0 Composition API 区别"></a>Vue2.0 Options API 与 Vue3.0 Composition API 区别</h1><h2 id="Vue2-0-Options-API"><a href="#Vue2-0-Options-API" class="headerlink" title="Vue2.0 Options API"></a>Vue2.0 Options API</h2><p>Options API, 即大家常说的选项 API。常用的有 <code>data</code>、<code>methods</code>、<code>computed</code>、<code>watch</code> 等属性和方法，共同处理页面逻辑。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> default &#123;</span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      属性A,</span><br><span class="line">      属性B</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  methods: &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  computed: &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  watch: &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当组件变的复杂的时候，对应的属性列表也会增长，以至于最终难以维护。<strong>且对 typeScript 的支持有限。</strong></p><span id="more"></span><h2 id="Vue3-0-Composition-API"><a href="#Vue3-0-Composition-API" class="headerlink" title="Vue3.0 Composition API"></a>Vue3.0 Composition API</h2><p>1.建立在 <code>setup</code> 函数之上。<br>2.<code>setup(props, context)&#123;&#125;</code> 在 <code>created</code> 实例被完全初始化之前执行<br>3.由于 <code>setup</code> 是在实例被初始化之前执行的，故在 setup 中的 this 上没有任何东西</p><p>Composition API 有 <code>setup</code>、<code>reactive</code>、<code>onMounted</code>、<code>onUnmounted</code>、<code>computed</code>、<code>watchEffect</code>等</p><p><strong>Composition API 代码是根据逻辑功能来组织的，一个功能的 api 都放在一起，实现高内聚，低耦合。</strong></p><p><img src="/images/20210715/11.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="function"><span class="title">useCount</span></span>() &#123;</span><br><span class="line">  <span class="built_in">let</span> count = ref(10)</span><br><span class="line"></span><br><span class="line">  const handleConut = () =&gt; &#123;</span><br><span class="line">    count.value = count.vale * 2</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">return</span> &#123;</span><br><span class="line">    count,</span><br><span class="line">    handleConut</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">export</span> default defineComponent(&#123;</span><br><span class="line">  <span class="function"><span class="title">setup</span></span>() &#123;</span><br><span class="line">    const &#123; count, handleConut &#125; = useCount()</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      count,</span><br><span class="line">      handleConut</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>当然 vue2.0 中也有 <code>mixin</code> 来重用代码。但是随着项目的复杂度变高，<code>mixin</code> 也会变得难以维护。会出现：<br>1.命名冲突<br>2.数据来源不清晰问题。</p><h2 id="Option-API-与-Compostion-API-生命周期的区别"><a href="#Option-API-与-Compostion-API-生命周期的区别" class="headerlink" title="Option API 与 Compostion API 生命周期的区别"></a>Option API 与 Compostion API 生命周期的区别</h2><p>可以通过在生命周期的钩子上加 <code>on</code> 来访问组件的生命周期钩子，例如：</p><table><thead><tr><th align="center">Options API</th><th align="center">Composition API</th></tr></thead><tbody><tr><td align="center">beforeCreate</td><td align="center">不需要</td></tr><tr><td align="center">created</td><td align="center">不需要</td></tr><tr><td align="center">beforeMount</td><td align="center">onBeforeMount</td></tr><tr><td align="center">mounted</td><td align="center">onMounted</td></tr><tr><td align="center">updated</td><td align="center">onUpdated</td></tr></tbody></table><h2 id="推荐"><a href="#推荐" class="headerlink" title="推荐"></a>推荐</h2><p>[vue 2.0 Options API 与 Vue3.0 Composition API]（<a href="https://www.cnblogs.com/gqx-html/p/14551008.html">https://www.cnblogs.com/gqx-html/p/14551008.html</a><br><a href="https://vue3js.cn/interview/">vue.js 每日一问</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Vue2-0-Options-API-与-Vue3-0-Composition-API-区别&quot;&gt;&lt;a href=&quot;#Vue2-0-Options-API-与-Vue3-0-Composition-API-区别&quot; class=&quot;headerlink&quot; title=&quot;Vue2.0 Options API 与 Vue3.0 Composition API 区别&quot;&gt;&lt;/a&gt;Vue2.0 Options API 与 Vue3.0 Composition API 区别&lt;/h1&gt;&lt;h2 id=&quot;Vue2-0-Options-API&quot;&gt;&lt;a href=&quot;#Vue2-0-Options-API&quot; class=&quot;headerlink&quot; title=&quot;Vue2.0 Options API&quot;&gt;&lt;/a&gt;Vue2.0 Options API&lt;/h2&gt;&lt;p&gt;Options API, 即大家常说的选项 API。常用的有 &lt;code&gt;data&lt;/code&gt;、&lt;code&gt;methods&lt;/code&gt;、&lt;code&gt;computed&lt;/code&gt;、&lt;code&gt;watch&lt;/code&gt; 等属性和方法，共同处理页面逻辑。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;export&lt;/span&gt; default &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;data&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      属性A,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      属性B&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  methods: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  computed: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  watch: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    ...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;当组件变的复杂的时候，对应的属性列表也会增长，以至于最终难以维护。&lt;strong&gt;且对 typeScript 的支持有限。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Vue" scheme="http://yoursite.com/categories/Vue/"/>
    
    
    <category term="Vue" scheme="http://yoursite.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>浏览器事件循环机制 (Event Loop)</title>
    <link href="http://yoursite.com/2021/07/12/2021-07-12/"/>
    <id>http://yoursite.com/2021/07/12/2021-07-12/</id>
    <published>2021-07-11T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器事件循环机制"><a href="#浏览器事件循环机制" class="headerlink" title="浏览器事件循环机制"></a>浏览器事件循环机制</h1><p><strong>JS 是单线程的，非阻塞的。</strong><br>虽然 JS 运行在浏览器中是单线程的，但是浏览器是事件驱动的(Event Driven), 浏览器中很多行为是异步的 (Asynchronized), 会创建事件并放入执行队列。<br>浏览器中很多异步行为都是由浏览器中的线程去完成，主要由以下 3 个线程去执行：</p><p>1.JS 引擎线程<br>2.GUI 渲染线程<br>3.事件触发线程</p><p>JS 非阻塞的主要通过 Event Loop 来实现。    </p><h2 id="浏览器的事件循环"><a href="#浏览器的事件循环" class="headerlink" title="浏览器的事件循环"></a>浏览器的事件循环</h2><p><img src="/images/20210712/1.png"></p><p>浏览器中的事件循环 Event Loop，分为同步执行栈和异步队列，首先会执行同步的任务，当同步任务执行完之后会从异步队列中取异步任务拿到同步执行栈中进行执行。</p><h3 id="执行栈和事件队列"><a href="#执行栈和事件队列" class="headerlink" title="执行栈和事件队列"></a>执行栈和事件队列</h3><p>JavaScript 引擎线程专门处理 JavaScript 脚本，JS 引擎主要由 2 个组件构成</p><p>1.堆(Memory Heap) - 内存分配发生的地方<br>2.栈(Call Stack) - 函数调用时会形成一个个栈帧(frame)</p><p>可以使用<a href="http://latentflip.com/loupe/">Loupe 工具</a>来了解 JavaScript 的调用堆栈、事件循环、回调队列如何执行的。</p><h4 id="执行栈"><a href="#执行栈" class="headerlink" title="执行栈"></a>执行栈</h4><p>每个函数执行的时候都会生成新的 <code>execution context(执行上下文)</code>，执行上下文会包含一些当前函数的参数、局部变量，它会被推入栈中，<code>running execution context(正在执行的上下文)</code>始终处于栈的顶部。当函数执行完后，它的上下文会从栈弹出。 </p><h4 id="事件队列-FIFO队列"><a href="#事件队列-FIFO队列" class="headerlink" title="事件队列 FIFO队列"></a>事件队列 FIFO队列</h4><p>先执行同步代码，遇到异步代码的执行，不会等待异步事件结果返回，而是将事件挂起，继续执行执行栈中的其他任务。<br>当异步事件返回结果，将它放到事件队列中，等待执行栈中的任务全部执行完成，然后主线程空闲状态，主线程会去查找事件队列中的任务，取第一个事件，然后把事件回调放到执行栈中，然后执行同步代码。</p><p><strong>同步代码属于宏任务会开始执行一次，不同的异步任务又被分为宏任务和微任务。</strong></p><span id="more"></span><h3 id="宏任务-Macro-Task-和微任务-Micro-Task"><a href="#宏任务-Macro-Task-和微任务-Micro-Task" class="headerlink" title="宏任务(Macro Task)和微任务(Micro Task)"></a>宏任务(Macro Task)和微任务(Micro Task)</h3><h4 id="宏任务"><a href="#宏任务" class="headerlink" title="宏任务"></a>宏任务</h4><p><strong>优先级低，先定义的先执行。</strong>包括：ajax，click，setTimeout，setInterval，事件绑定，postMessage，MessageChannel</p><h4 id="微任务"><a href="#微任务" class="headerlink" title="微任务"></a>微任务</h4><p><strong>微任务，优先级高，并且可以插队，不是先定义先执行。</strong> 包括：promise 中的 then，observer，MutationObserver，setImmediate。</p><p>宏任务包括 Script, setTimeout/setInterval, setImmediate, postMessage, I/O 和 UI rendering。<br>微任务包括 Promise.then(), Object.observe 和 Mutation.Observer。</p><p>说明:<br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Window/setImmediate">setImmediate 非标准</a><br><a href="">Object.observe 已废弃</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/MutationObserver">Mutation.Observer</a></p><h3 id="运行机制"><a href="#运行机制" class="headerlink" title="运行机制"></a>运行机制</h3><p>异步任务的返回结果会被放到一个任务队列中，根据异步事件的类型，将结果放到对应的宏任务和微任务队列中去。<br>当<code>执行栈</code>为空时，=&gt; 查找微任务队列事件 =&gt; 宏任务队列事件。</p><h2 id="经典题目分析"><a href="#经典题目分析" class="headerlink" title="经典题目分析"></a>经典题目分析</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">async1</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">&#x27;async1 start&#x27;</span>);</span><br><span class="line">  await async2();</span><br><span class="line">  console.log(<span class="string">&#x27;async1 end&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">async <span class="keyword">function</span> <span class="function"><span class="title">async2</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">&#x27;async2&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line">console.log(<span class="string">&#x27;script start&#x27;</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">&#x27;setTimeout&#x27;</span>);</span><br><span class="line">&#125;, 0)</span><br><span class="line">async1();</span><br><span class="line">new Promise(<span class="keyword">function</span>(resolve) &#123;</span><br><span class="line">  console.log(<span class="string">&#x27;promise1&#x27;</span>);</span><br><span class="line">  resolve();</span><br><span class="line">&#125;).<span class="keyword">then</span>(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">  console.log(<span class="string">&#x27;promise2&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line">console.log(<span class="string">&#x27;script end&#x27;</span>);</span><br></pre></td></tr></table></figure><p>1.执行同步代码，输出 <code>script start</code><br>2.遇到 setTimeout，将回调压入宏任务队列<br>3.执行 async1，输出 <code>async1 start</code>，然后执行 async2，输出 <code>async2</code>，将 await async2() 后的代码压到微任务队列中<br>4.执行 Promise，输出 <code>promise1</code>, 将 Promise.then() 压入到微任务队列中。<br>5.输出 <code>script end</code> ，至此同步代码执行完成<br>6.执行微任务队列中的代码，输出 <code>async1 end</code>，然后输出 <code>promise2</code>，此时微任务队列执行完成。<br>7.执行宏任务队列代码，输出 <code>setTimeout</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="string">&#x27;start&#x27;</span>);</span><br><span class="line">setTimeout(() =&gt; &#123;</span><br><span class="line">  console.log(<span class="string">&#x27;children2&#x27;</span>);</span><br><span class="line">  Promise.resolve().<span class="keyword">then</span>(() =&gt; &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;children3&#x27;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;, 0);</span><br><span class="line"></span><br><span class="line">new Promise(<span class="keyword">function</span>(resolve, reject) &#123;</span><br><span class="line">  console.log(<span class="string">&#x27;children4&#x27;</span>);</span><br><span class="line">  setTimeout(<span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;children5&#x27;</span>);</span><br><span class="line">    resolve(<span class="string">&#x27;children6&#x27;</span>)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;).<span class="keyword">then</span>((res) =&gt; &#123;</span><br><span class="line">  console.log(<span class="string">&#x27;children7&#x27;</span>);</span><br><span class="line">  setTimeout(() =&gt; &#123;</span><br><span class="line">    console.log(res);</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>1.执行同步代码，输出 <code>start</code><br>2.setTimeout 压入宏任务队列1<br>3.遇到 Promise, 输出 <code>children4</code>，遇到 setTimeout 压入宏任务队列2，Promise.then 还没执行。<br>4.执行宏任务队列1，输出 <code>children2</code><br>5.执行宏任务队列1中的微任务 Promise.then()，输出 <code>children3</code><br>6.执行宏任务队列2，输出 <code>children5</code>，并 resolve 执行 Promise.then，输出 <code>children7</code><br>7.遇到 setTimeout 压入宏任务队列，此时微任务队列没任务，执行宏任务，输出 <code>children6</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6844903606466904078">浏览器事件循环机制（event loop）</a><br><a href="https://segmentfault.com/a/1190000022805523">JavaScript中的Event Loop（事件循环）机制</a><br><a href="http://lynnelv.github.io/js-event-loop-browser">深入理解js事件循环机制（浏览器篇)</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;浏览器事件循环机制&quot;&gt;&lt;a href=&quot;#浏览器事件循环机制&quot; class=&quot;headerlink&quot; title=&quot;浏览器事件循环机制&quot;&gt;&lt;/a&gt;浏览器事件循环机制&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;JS 是单线程的，非阻塞的。&lt;/strong&gt;&lt;br&gt;虽然 JS 运行在浏览器中是单线程的，但是浏览器是事件驱动的(Event Driven), 浏览器中很多行为是异步的 (Asynchronized), 会创建事件并放入执行队列。&lt;br&gt;浏览器中很多异步行为都是由浏览器中的线程去完成，主要由以下 3 个线程去执行：&lt;/p&gt;
&lt;p&gt;1.JS 引擎线程&lt;br&gt;2.GUI 渲染线程&lt;br&gt;3.事件触发线程&lt;/p&gt;
&lt;p&gt;JS 非阻塞的主要通过 Event Loop 来实现。    &lt;/p&gt;
&lt;h2 id=&quot;浏览器的事件循环&quot;&gt;&lt;a href=&quot;#浏览器的事件循环&quot; class=&quot;headerlink&quot; title=&quot;浏览器的事件循环&quot;&gt;&lt;/a&gt;浏览器的事件循环&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;/images/20210712/1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;浏览器中的事件循环 Event Loop，分为同步执行栈和异步队列，首先会执行同步的任务，当同步任务执行完之后会从异步队列中取异步任务拿到同步执行栈中进行执行。&lt;/p&gt;
&lt;h3 id=&quot;执行栈和事件队列&quot;&gt;&lt;a href=&quot;#执行栈和事件队列&quot; class=&quot;headerlink&quot; title=&quot;执行栈和事件队列&quot;&gt;&lt;/a&gt;执行栈和事件队列&lt;/h3&gt;&lt;p&gt;JavaScript 引擎线程专门处理 JavaScript 脚本，JS 引擎主要由 2 个组件构成&lt;/p&gt;
&lt;p&gt;1.堆(Memory Heap) - 内存分配发生的地方&lt;br&gt;2.栈(Call Stack) - 函数调用时会形成一个个栈帧(frame)&lt;/p&gt;
&lt;p&gt;可以使用&lt;a href=&quot;http://latentflip.com/loupe/&quot;&gt;Loupe 工具&lt;/a&gt;来了解 JavaScript 的调用堆栈、事件循环、回调队列如何执行的。&lt;/p&gt;
&lt;h4 id=&quot;执行栈&quot;&gt;&lt;a href=&quot;#执行栈&quot; class=&quot;headerlink&quot; title=&quot;执行栈&quot;&gt;&lt;/a&gt;执行栈&lt;/h4&gt;&lt;p&gt;每个函数执行的时候都会生成新的 &lt;code&gt;execution context(执行上下文)&lt;/code&gt;，执行上下文会包含一些当前函数的参数、局部变量，它会被推入栈中，&lt;code&gt;running execution context(正在执行的上下文)&lt;/code&gt;始终处于栈的顶部。当函数执行完后，它的上下文会从栈弹出。 &lt;/p&gt;
&lt;h4 id=&quot;事件队列-FIFO队列&quot;&gt;&lt;a href=&quot;#事件队列-FIFO队列&quot; class=&quot;headerlink&quot; title=&quot;事件队列 FIFO队列&quot;&gt;&lt;/a&gt;事件队列 FIFO队列&lt;/h4&gt;&lt;p&gt;先执行同步代码，遇到异步代码的执行，不会等待异步事件结果返回，而是将事件挂起，继续执行执行栈中的其他任务。&lt;br&gt;当异步事件返回结果，将它放到事件队列中，等待执行栈中的任务全部执行完成，然后主线程空闲状态，主线程会去查找事件队列中的任务，取第一个事件，然后把事件回调放到执行栈中，然后执行同步代码。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;同步代码属于宏任务会开始执行一次，不同的异步任务又被分为宏任务和微任务。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
    <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>浏览器进程与线程详解</title>
    <link href="http://yoursite.com/2021/07/10/2021-07-10/"/>
    <id>http://yoursite.com/2021/07/10/2021-07-10/</id>
    <published>2021-07-09T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.326Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浏览器进程与线程详解"><a href="#浏览器进程与线程详解" class="headerlink" title="浏览器进程与线程详解"></a>浏览器进程与线程详解</h1><h2 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h2><h3 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h3><p>进程是 CPU 资源分配的最小单位。<br>多进程：多进程是指同一个时间里，同一个计算机系统允许多个进程处于运行状态。多进程可以在编代码的时候，同时听歌，且进程之间不会相互干扰。</p><h3 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h3><p>1.一个进程由一个或者多个线程组成，线程是一个进程中代码的不同执行路线。<br>2.进程相互独立，同一个进程下的各个线程共享程序的内存空间，包括代码段、数据集、堆等。</p><h2 id="浏览器中的进程与线程"><a href="#浏览器中的进程与线程" class="headerlink" title="浏览器中的进程与线程"></a>浏览器中的进程与线程</h2><h3 id="浏览器是多进程的"><a href="#浏览器是多进程的" class="headerlink" title="浏览器是多进程的"></a>浏览器是多进程的</h3><p><img src="/images/20210710/01.png"></p><p>1.Browser 进程: 浏览器的主进程(负责协调、主控)<br>2.第三方插件进程: 每种类型的插件对应一个进程，仅当适用该插件时才创建。<br>3.GPU进程: 最多一个，用于 3D 绘制<br>4.<strong>浏览器渲染进程(内核)</strong>: 默认每个 Tab 标签页面就是一个进程，互不影响，控制页面的渲染，脚本执行，事件处理等。</p><p>浏览器会优化:<strong>多个空白的 tab 标签会合并成一个进程。</strong></p><span id="more"></span><p>多进程浏览器优点:<br>1.避免单个页面渲染影响整个浏览器<br>2.避免第三方插件影响整个浏览器<br>3.多进程利用了多核优势<br>4.方便沙盒模式</p><h3 id="浏览器中的渲染进程-Renderer"><a href="#浏览器中的渲染进程-Renderer" class="headerlink" title="浏览器中的渲染进程 Renderer"></a>浏览器中的渲染进程 Renderer</h3><p><img src="/images/20210710/02.png"></p><p><strong>浏览器中的渲染进程是多线程的</strong></p><p>1.GUI 渲染线程</p><p>1.1 负责渲染浏览器界面,解析 HTML、CSS 构建 DOM树、CSSOM树<br>1.2 当界面需要重绘(Repaint)或由于某种操作引发回流(reflow)时,该线程就会执行重新渲染。</p><p>2.JS 引擎线程</p><p>JS 内核，主要负责处理 JavaScript 脚本程序，例如 V8 引擎。</p><p><strong>一个 tab 渲染进程只有一个 JS 线程运行，即 JS 引擎是单线程的。</strong></p><p><strong>JavaScript 是单线程的</strong><br>JavaScript 为处理页面中用户的交互，以及操作DOM树、CSS样式树来给用户呈现一份动态而丰富的交互体验和服务器逻辑的交互处理。如果 JavaScript 是多线程的方式来操作这些 UI DOM，则可能出现 UI 操作的冲突。如果 Javascript 是多线程的话，在多线程的交互下，处于 UI 中的 DOM 节点就可能成为一个临界资源，假设存在两个线程同时操作一个 DOM，一个负责修改一个负责删除，那么这个时候就需要浏览器来裁决如何生效哪个线程的执行结果。当然我们可以通过锁来解决上面的问题。但为了避免因为引入了锁而带来更大的复杂性，Javascript在最初就选择了单线程执行。</p><p><strong>GUI 渲染线程与 JS 引擎线程互斥。GUI 渲染线程优先级低于 JS 引擎线程。在 JS 引擎线程工作时会被挂起。</strong><br>由于 GUI 渲染线程与 JavaScript 执行线程是互斥的关系，当浏览器在执行 JavaScript 程序的时候，GUI 渲染线程会被保存在一个队列中，直到 JS 程序执行完成，才会接着执行。因此如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉</p><p>3.事件触发线程</p><p>当一个事件被触发时该线程会把事件添加到待处理队列的队尾，等待 JS 引擎线程的处理。这些事件可以是当前执行的代码块如定时任务、也可来自浏览器内核的其他线程如鼠标点击、AJAX 异步请求等，但由于 JS 的单线程关系所有这些事件都得排队等待 JS 引擎线程处理。</p><p>4.定时器线程</p><p>浏览器定时计数器并不是由 JavaScript 引擎线程计数的, 因为 JavaScript 引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确, 因此通过单独线程来计时并触发定时是更为合理的方案。</p><p>5.网络请求线程</p><p>在 XMLHttpRequest 在连接后是通过浏览器新开一个线程请求， 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件放到 JavaScript 引擎的处理队列中等待处理。</p><h3 id="Web-workers"><a href="#Web-workers" class="headerlink" title="Web workers"></a>Web workers</h3><p><strong>Web worker 是 JS 引擎线程向浏览器申请的一个子线程，解决单线程 JS 引擎进行密集型运算堵塞 GUI 渲染线程问题。</strong><br>Service Worker 是基于 web worker 的一个独立线程，且加上了离线缓存的功能，详细的 <a href="/2021/06/13/2021-06-13/">service worker</a> 介绍，可以看这篇。</p><h2 id="浏览器渲染流程"><a href="#浏览器渲染流程" class="headerlink" title="浏览器渲染流程"></a>浏览器渲染流程</h2><p>用户请求 =&gt; Broswer 进程 =&gt; 渲染进程 Renderer =&gt; GUI 渲染线程，加载网页开始渲染(可能需要 GPU 进程协助, JS 引擎线程引起的回流 + 重绘) =&gt; Renderer 进程 =&gt; Broswer 进程</p><p><strong>GUI 渲染线程渲染过程:</strong></p><p><img src="/images/20210710/03.png"></p><p>1.解析 html 建立 dom 树, 解析 css 建立 cssom 树<br>2.dom 树和 cssom 树组成 render 树<br>3.布局 render 树（Layout/reflow），负责各元素尺寸、位置的计算 (dom 的尺寸、位置的变化会引起 reflow)<br>4.绘制 render 树（paint），绘制页面像素信息 (样式变化会引起 repaint)<br>5.浏览器渲染</p><p><strong>reflow 一定会引起 repaint, 但是 repaint 不一定会引起 reflow。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000017048240">浏览器进程与线程详解</a><br><a href="https://segmentfault.com/a/1190000017204460">浏览器进程线程、Web Workers、Event Loop 图解</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;浏览器进程与线程详解&quot;&gt;&lt;a href=&quot;#浏览器进程与线程详解&quot; class=&quot;headerlink&quot; title=&quot;浏览器进程与线程详解&quot;&gt;&lt;/a&gt;浏览器进程与线程详解&lt;/h1&gt;&lt;h2 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h2&gt;&lt;h3 id=&quot;进程&quot;&gt;&lt;a href=&quot;#进程&quot; class=&quot;headerlink&quot; title=&quot;进程&quot;&gt;&lt;/a&gt;进程&lt;/h3&gt;&lt;p&gt;进程是 CPU 资源分配的最小单位。&lt;br&gt;多进程：多进程是指同一个时间里，同一个计算机系统允许多个进程处于运行状态。多进程可以在编代码的时候，同时听歌，且进程之间不会相互干扰。&lt;/p&gt;
&lt;h3 id=&quot;线程&quot;&gt;&lt;a href=&quot;#线程&quot; class=&quot;headerlink&quot; title=&quot;线程&quot;&gt;&lt;/a&gt;线程&lt;/h3&gt;&lt;p&gt;1.一个进程由一个或者多个线程组成，线程是一个进程中代码的不同执行路线。&lt;br&gt;2.进程相互独立，同一个进程下的各个线程共享程序的内存空间，包括代码段、数据集、堆等。&lt;/p&gt;
&lt;h2 id=&quot;浏览器中的进程与线程&quot;&gt;&lt;a href=&quot;#浏览器中的进程与线程&quot; class=&quot;headerlink&quot; title=&quot;浏览器中的进程与线程&quot;&gt;&lt;/a&gt;浏览器中的进程与线程&lt;/h2&gt;&lt;h3 id=&quot;浏览器是多进程的&quot;&gt;&lt;a href=&quot;#浏览器是多进程的&quot; class=&quot;headerlink&quot; title=&quot;浏览器是多进程的&quot;&gt;&lt;/a&gt;浏览器是多进程的&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;/images/20210710/01.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;1.Browser 进程: 浏览器的主进程(负责协调、主控)&lt;br&gt;2.第三方插件进程: 每种类型的插件对应一个进程，仅当适用该插件时才创建。&lt;br&gt;3.GPU进程: 最多一个，用于 3D 绘制&lt;br&gt;4.&lt;strong&gt;浏览器渲染进程(内核)&lt;/strong&gt;: 默认每个 Tab 标签页面就是一个进程，互不影响，控制页面的渲染，脚本执行，事件处理等。&lt;/p&gt;
&lt;p&gt;浏览器会优化:&lt;strong&gt;多个空白的 tab 标签会合并成一个进程。&lt;/strong&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="web" scheme="http://yoursite.com/categories/web/"/>
    
    
    <category term="web" scheme="http://yoursite.com/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>算法之深度优先、广度优先</title>
    <link href="http://yoursite.com/2021/07/05/2021-07-05/"/>
    <id>http://yoursite.com/2021/07/05/2021-07-05/</id>
    <published>2021-07-04T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.326Z</updated>
    
    
    
    
    <category term="Algorithm" scheme="http://yoursite.com/categories/Algorithm/"/>
    
    
    <category term="Algorithm" scheme="http://yoursite.com/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>浅谈 service worker</title>
    <link href="http://yoursite.com/2021/06/13/2021-06-13/"/>
    <id>http://yoursite.com/2021/06/13/2021-06-13/</id>
    <published>2021-06-12T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="浅谈-service-worker"><a href="#浅谈-service-worker" class="headerlink" title="浅谈 service worker"></a>浅谈 service worker</h1><p><a href="https://developers.google.com/web/fundamentals/primers/service-workers">service Worker 简介</a></p><p>service worker 是浏览器在后台独立于网页运行的脚本, 它打开了通向不需要网页或用户交互的功能的大门。</p><p><img src="/images/20210613/01.png"></p><h2 id="service-worker-简介"><a href="#service-worker-简介" class="headerlink" title="service worker 简介"></a>service worker 简介</h2><ul><li>基于 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers">web worker</a>: 一个独立于 JavaScript 主线程的独立线程，在里面执行需要消耗大量资源的操作不会阻塞主线程</li><li>在 web worker 的基础上增加了离线缓存的能力</li><li>本质上充当 Web 应用程序（服务器）与浏览器之间的代理服务器，可以拦截全站的请求，并作出相应的请求。</li><li>创建有效的离线体验（将一些不常更新的内容缓存在浏览器，提高访问体验）</li><li>由事件驱动的, 具有生命周期</li><li>可以访问 cache 和 indexDB</li><li>支持推送</li><li>可以让开发者自己控制管理缓存的内容以及版本</li></ul><p>service worker 可以拦截当前网站所有的请求，进行判断，如果需要向服务器发送请求的就转给服务器，如果可以使用缓存的就使用缓存，大大提高浏览器的体验。<br>在客户端离线的状态下，可以将静态资源进行缓存，从而减少白屏时间，加快页面响应速度。</p><span id="more"></span><h2 id="service-worker-使用"><a href="#service-worker-使用" class="headerlink" title="service worker 使用"></a>service worker 使用</h2><p><code>注册SW =&gt; 安装SW =&gt; 激活SW =&gt; 空闲 =&gt; (缓存和返回请求/终止)</code>。</p><p>通过在页面中对其进行注册来启动安装。这将告诉浏览器 service Worker JavaScript 文件的位置。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="string">&#x27;serviceWorker&#x27;</span> <span class="keyword">in</span> navigator) &#123;</span><br><span class="line">  window.addEventListener(<span class="string">&#x27;load&#x27;</span>, <span class="function"><span class="title">function</span></span>() &#123;</span><br><span class="line">    navigator.serviceWorker.register(<span class="string">&#x27;/service-worker.js&#x27;</span>, &#123; scope: <span class="string">&#x27;./&#x27;</span> &#125;).<span class="keyword">then</span>(<span class="keyword">function</span>(registration) &#123;</span><br><span class="line">      // Registration was successful</span><br><span class="line">      console.log(<span class="string">&#x27;ServiceWorker registration successful with scope: &#x27;</span>, registration.scope);</span><br><span class="line">    &#125;, <span class="keyword">function</span>(err) &#123;</span><br><span class="line">      // registration failed :(</span><br><span class="line">      console.log(<span class="string">&#x27;ServiceWorker registration failed: &#x27;</span>, err);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以使用 <a href="chrome://inspect/#service-workers">chrome inspect</a> 来检查 service Worker 是否已启用。<br>也可以 <code>F12 -&gt; Application -&gt; Service Workers</code> 查看</p><h2 id="使用-service-worker-注意事项"><a href="#使用-service-worker-注意事项" class="headerlink" title="使用 service worker 注意事项"></a>使用 service worker 注意事项</h2><ul><li>service worker 运行在 worker 上下文, 不能不能访问DOM</li><li>service worker 完全异步，同步 API (如 xhr 和 localstorage) 不能在其中使用</li><li>出于安全考虑，service worker 只能在 https 和 localhost 环境下使用</li><li>service worker 其生命周期与页面无关</li></ul><h2 id="service-worker-在-vue-项目中的实际应用"><a href="#service-worker-在-vue-项目中的实际应用" class="headerlink" title="service worker 在 vue 项目中的实际应用"></a>service worker 在 vue 项目中的实际应用</h2><p>在 vue 项目中使用库 <code>register-service-worker</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yarn add register-service-worker</span><br><span class="line"></span><br><span class="line">// main.js</span><br><span class="line">import <span class="string">&#x27;./register-service-worker&#x27;</span></span><br></pre></td></tr></table></figure><p>在项目的根目录下会有一个 <code>registerServiceWorker.js</code> 文件。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">import &#123; register &#125; from <span class="string">&#x27;register-service-worker&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (process.env.NODE_ENV === <span class="string">&#x27;production&#x27;</span>) &#123;</span><br><span class="line">  register(`<span class="variable">$&#123;process.env.BASE_URL&#125;</span>service-worker.js`, &#123;</span><br><span class="line">    <span class="function"><span class="title">ready</span></span>() &#123;</span><br><span class="line">      console.log(</span><br><span class="line">        <span class="string">&#x27;App is being served from cache by a service worker.\n&#x27;</span> +</span><br><span class="line">          <span class="string">&#x27;For more details, visit https://goo.gl/AFskqB&#x27;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">registered</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">&#x27;Service worker has been registered.&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">cached</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">&#x27;Content has been cached for offline use.&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">updatefound</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">&#x27;New content is downloading.&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">updated</span></span>() &#123;</span><br><span class="line">      console.log(<span class="string">&#x27;New content is available; please refresh.&#x27;</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">offline</span></span>() &#123;</span><br><span class="line">      console.log(</span><br><span class="line">        <span class="string">&#x27;No internet connection found. App is running in offline mode.&#x27;</span></span><br><span class="line">      )</span><br><span class="line">    &#125;,</span><br><span class="line">    error(error) &#123;</span><br><span class="line">      console.error(<span class="string">&#x27;Error during service worker registration:&#x27;</span>, error)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>默认的功能有:</p><ul><li>所有构建文件的预缓存</li><li>离线加载应用程序的能力</li><li>在应用程序中使用 <code>service worker</code> 中的注册事件</li></ul><h3 id="service-worker-用法"><a href="#service-worker-用法" class="headerlink" title="service worker 用法"></a>service worker 用法</h3><ol><li>service worker 线程发送消息到 web Application</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">updated(registration) &#123;</span><br><span class="line">  document.dispatchEvent(new CustomEvent(<span class="string">&#x27;methodName&#x27;</span>, &#123; detail: registration &#125;))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>web Application 监听线程消息</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">document.addEventListener(<span class="string">&#x27;methodName&#x27;</span>, this.appUpdateUI, &#123; once: <span class="literal">true</span> &#125;)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">appUpdateUI(e) &#123;</span><br><span class="line">  // 获取 registration</span><br><span class="line">  this.registration = registration</span><br><span class="line">  console.log(e.detail)</span><br><span class="line">&#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><ol start="3"><li>web Application 层通过 <code>postMessage</code> 发送消息到 service worker 线程中</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">this.registration.waiting.postMessage(&#123; <span class="built_in">type</span>: <span class="string">&#x27;SKIP_WAITING&#x27;</span> &#125;)</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000019863217">service worker 用法详解</a><br><a href="https://segmentfault.com/a/1190000022103402">service worker 是什么</a><br><a href="https://levelup.gitconnected.com/vue-pwa-example-298a8ea953c9">service worker 在 vue 中的应用</a><br><a href="https://juejin.cn/post/6844904004464410638">一文了解 service worker</a> </p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;浅谈-service-worker&quot;&gt;&lt;a href=&quot;#浅谈-service-worker&quot; class=&quot;headerlink&quot; title=&quot;浅谈 service worker&quot;&gt;&lt;/a&gt;浅谈 service worker&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://developers.google.com/web/fundamentals/primers/service-workers&quot;&gt;service Worker 简介&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;service worker 是浏览器在后台独立于网页运行的脚本, 它打开了通向不需要网页或用户交互的功能的大门。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/images/20210613/01.png&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;service-worker-简介&quot;&gt;&lt;a href=&quot;#service-worker-简介&quot; class=&quot;headerlink&quot; title=&quot;service worker 简介&quot;&gt;&lt;/a&gt;service worker 简介&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;基于 &lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers&quot;&gt;web worker&lt;/a&gt;: 一个独立于 JavaScript 主线程的独立线程，在里面执行需要消耗大量资源的操作不会阻塞主线程&lt;/li&gt;
&lt;li&gt;在 web worker 的基础上增加了离线缓存的能力&lt;/li&gt;
&lt;li&gt;本质上充当 Web 应用程序（服务器）与浏览器之间的代理服务器，可以拦截全站的请求，并作出相应的请求。&lt;/li&gt;
&lt;li&gt;创建有效的离线体验（将一些不常更新的内容缓存在浏览器，提高访问体验）&lt;/li&gt;
&lt;li&gt;由事件驱动的, 具有生命周期&lt;/li&gt;
&lt;li&gt;可以访问 cache 和 indexDB&lt;/li&gt;
&lt;li&gt;支持推送&lt;/li&gt;
&lt;li&gt;可以让开发者自己控制管理缓存的内容以及版本&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;service worker 可以拦截当前网站所有的请求，进行判断，如果需要向服务器发送请求的就转给服务器，如果可以使用缓存的就使用缓存，大大提高浏览器的体验。&lt;br&gt;在客户端离线的状态下，可以将静态资源进行缓存，从而减少白屏时间，加快页面响应速度。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue2 响应式 &amp; Vue3 响应式数据原理</title>
    <link href="http://yoursite.com/2021/06/06/2021-06-06/"/>
    <id>http://yoursite.com/2021/06/06/2021-06-06/</id>
    <published>2021-06-05T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.325Z</updated>
    
    
    
    
    <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>es7 语法糖 async/await 拙见</title>
    <link href="http://yoursite.com/2021/05/30/2021-05-30/"/>
    <id>http://yoursite.com/2021/05/30/2021-05-30/</id>
    <published>2021-05-29T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.325Z</updated>
    
    
    
    
    <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Vue2 中 computed 和 watch 区别</title>
    <link href="http://yoursite.com/2021/05/22/2021-05-22/"/>
    <id>http://yoursite.com/2021/05/22/2021-05-22/</id>
    <published>2021-05-21T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Vue2-中-computed-和-watch-区别"><a href="#Vue2-中-computed-和-watch-区别" class="headerlink" title="Vue2 中 computed 和 watch 区别"></a>Vue2 中 computed 和 watch 区别</h1><p>两者 API 都实现了对数据的监听，但还是有些许差别的。可以看<a href="https://cn.vuejs.org/v2/guide/computed.html">官网介绍</a></p><h2 id="computed"><a href="#computed" class="headerlink" title="computed"></a>computed</h2><p>对于视图渲染的任何复杂逻辑都可以使用 <strong>计算属性 computed</strong><br>使用 <code>computed</code> 可以防止 <code>template</code> 模版过重，且使用大量复杂逻辑表达式处理数据时，会对页面的可维护性造成很大影响<br><strong>计算的属性不在 data 和 props 中</strong></p><p>基础使用</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="built_in">id</span>=<span class="string">&quot;example&quot;</span>&gt;</span><br><span class="line">  &lt;p&gt;Original message: <span class="string">&quot;&#123;&#123; message &#125;&#125;&quot;</span>&lt;/p&gt;</span><br><span class="line">  &lt;p&gt;Computed reversed message: <span class="string">&quot;&#123;&#123; reversedMessage &#125;&#125;&quot;</span>&lt;/p&gt;</span><br><span class="line"></span><br><span class="line">  // bad</span><br><span class="line">  &lt;p&gt;&#123;&#123; this.message.split(<span class="string">&#x27;&#x27;</span>).reverse().<span class="built_in">join</span>(<span class="string">&#x27;&#x27;</span>) &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">var vm = new Vue(&#123;</span><br><span class="line">  el: <span class="string">&#x27;#example&#x27;</span>,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">data</span></span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> &#123;</span><br><span class="line">      message: <span class="string">&#x27;Hello&#x27;</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  computed: &#123;</span><br><span class="line">    // 计算属性的 getter</span><br><span class="line">    reversedMessage: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">      // `this` 指向 vm 实例</span><br><span class="line">      <span class="built_in">return</span> this.message.split(<span class="string">&#x27;&#x27;</span>).reverse().<span class="built_in">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><span id="more"></span><h3 id="只有依赖数据发生改变，才会重新进行计算"><a href="#只有依赖数据发生改变，才会重新进行计算" class="headerlink" title="只有依赖数据发生改变，才会重新进行计算"></a>只有依赖数据发生改变，才会重新进行计算</h3><p>计算属性基于 <code>data</code> 中声明过或者父组件传递的 <code>props</code> 中的数据通过计算得到的一个<strong>新值</strong>。<br>在 <code>computed</code> 方法中使用未声明的属性会报错。</p><h3 id="computed-带有缓存功能"><a href="#computed-带有缓存功能" class="headerlink" title="computed 带有缓存功能"></a>computed 带有缓存功能</h3><p><code>computed</code> 内定义的 <code>function</code> 只执行一次，仅当初始化显示或者相关的 data、props 等属性数据发生变化的时候调用<br><strong><code>computed</code> 属性值默认会缓存计算结果，计算属性是基于它们的响应式依赖进行缓存的</strong><br>只有当 <code>computed</code> 属性被使用后，才会执行 <code>computed</code> 的代码，在重复的调用中，只要依赖数据不变，直接取缓存中的计算结果。只有依赖型数据发生改变，<code>computed</code> 才会重新计算</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;p&gt;姓名：&#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;姓名：&#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;姓名：&#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;姓名：&#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt;</span><br><span class="line">&lt;p&gt;姓名：&#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt;</span><br><span class="line">... ... </span><br><span class="line"></span><br><span class="line">computed: &#123;</span><br><span class="line">  reversedMessage: <span class="function"><span class="title">function</span></span> () &#123;</span><br><span class="line">    console.log(<span class="string">&#x27;computed&#x27;</span>) // 在控制台只打印了一次</span><br><span class="line">    <span class="built_in">return</span> this.message.split(<span class="string">&#x27;&#x27;</span>).reverse().<span class="built_in">join</span>(<span class="string">&#x27;&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="computed-属性的高级使用"><a href="#computed-属性的高级使用" class="headerlink" title="computed 属性的高级使用"></a>computed 属性的高级使用</h3><p>在 <code>computed</code> 中的属性都有一个 <code>get</code> 和一个 <code>set</code> 方法。<br>当数据变化时，调用 set 方法。可以通过计算属性的 getter/setter 方法来实现对属性数据的显示和监视，即双向绑定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">computed: &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    <span class="function"><span class="title">get</span></span>() &#123; </span><br><span class="line">      // 读取当前属性值的回调，根据相关的数据计算并返回当前属性的值</span><br><span class="line">      <span class="built_in">return</span> this.firstName + <span class="string">&#x27; &#x27;</span> + this.lastName</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="built_in">set</span>(val) &#123;</span><br><span class="line">      // 当属性值 fullName 发生改变时回调，更新相关的属性数据，val就是 fullName 的最新属性值</span><br><span class="line">      const names = val ? val.split(<span class="string">&#x27; &#x27;</span>) : []</span><br><span class="line">      this.firstName = names[0]</span><br><span class="line">      this.lastName = names[1]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p><a href="https://cn.vuejs.org/v2/api/#vm-watch">watch 官网介绍</a></p><p>观察和响应 Vue 实例上数据变动 <strong>监听属性 watch</strong></p><p>通过 vm 对象的 $watch() 或 watch 配置来监听 Vue 实例上的属性变化，或某些特定数据的变化，然后执行某些具体的业务逻辑操作。<br>当属性变化时，回调函数自动调用，在函数内部进行计算。其可以监听的数据来源：data，props，computed 内的数据。</p><h3 id="监听的属性变更，则触发相应的操作"><a href="#监听的属性变更，则触发相应的操作" class="headerlink" title="监听的属性变更，则触发相应的操作"></a>监听的属性变更，则触发相应的操作</h3><p>接收两个参数，第一个参数是最新的值，第二个参数是之前的值。<br>监听的数据必须是 <code>data</code>, <code>props</code> 中声明过的属性。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">...</span><br><span class="line">watch: &#123;</span><br><span class="line">  // 监听 data 中的 firstName，如果发生了变化，就把变化的值给 data 中的 fullName， val 就是 firstName 的最新值</span><br><span class="line">  firstName: <span class="keyword">function</span>(val) &#123; </span><br><span class="line">    this.fullName = val + <span class="string">&#x27; &#x27;</span> + this.lastName</span><br><span class="line">  &#125;,</span><br><span class="line">  fullName.lastName: &#123;</span><br><span class="line">    handler(newVal, oldVal) &#123;</span><br><span class="line">      console.log(newVal, oldVal)</span><br><span class="line">    &#125;,</span><br><span class="line">    deep: <span class="literal">true</span>,</span><br><span class="line">    immediate: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>监听复杂数据类型就需要用到深度监听 <code>deep</code></p><h2 id="computed-和-watch-的区别"><a href="#computed-和-watch-的区别" class="headerlink" title="computed 和 watch 的区别"></a>computed 和 watch 的区别</h2><table><thead><tr><th align="center"></th><th align="center">computed</th><th align="center">watch</th></tr></thead><tbody><tr><td align="center">监听数据源</td><td align="center">data、props</td><td align="center">data，props，computed 内的数据</td></tr><tr><td align="center">支持缓存</td><td align="center">支持</td><td align="center">不支持</td></tr><tr><td align="center">支持异步操作</td><td align="center">不支持</td><td align="center">支持</td></tr></tbody></table><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>如果一个数据依赖于其他数据，处理复杂的逻辑运算，则使用 <code>computed</code></strong><br><strong>如果要监听某个数据的变更，并且执行一些业务逻辑，则使用 <code>watch</code></strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://segmentfault.com/a/1190000038534977">Vue 中 computed 和 watch 的区别1</a><br><a href="https://segmentfault.com/a/1190000022740275">Vue 中 computed 和 watch 的区别2</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Vue2-中-computed-和-watch-区别&quot;&gt;&lt;a href=&quot;#Vue2-中-computed-和-watch-区别&quot; class=&quot;headerlink&quot; title=&quot;Vue2 中 computed 和 watch 区别&quot;&gt;&lt;/a&gt;Vue2 中 computed 和 watch 区别&lt;/h1&gt;&lt;p&gt;两者 API 都实现了对数据的监听，但还是有些许差别的。可以看&lt;a href=&quot;https://cn.vuejs.org/v2/guide/computed.html&quot;&gt;官网介绍&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;computed&quot;&gt;&lt;a href=&quot;#computed&quot; class=&quot;headerlink&quot; title=&quot;computed&quot;&gt;&lt;/a&gt;computed&lt;/h2&gt;&lt;p&gt;对于视图渲染的任何复杂逻辑都可以使用 &lt;strong&gt;计算属性 computed&lt;/strong&gt;&lt;br&gt;使用 &lt;code&gt;computed&lt;/code&gt; 可以防止 &lt;code&gt;template&lt;/code&gt; 模版过重，且使用大量复杂逻辑表达式处理数据时，会对页面的可维护性造成很大影响&lt;br&gt;&lt;strong&gt;计算的属性不在 data 和 props 中&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;基础使用&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;div &lt;span class=&quot;built_in&quot;&gt;id&lt;/span&gt;=&lt;span class=&quot;string&quot;&gt;&amp;quot;example&amp;quot;&lt;/span&gt;&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;p&amp;gt;Original message: &lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;#123;&amp;#123; message &amp;#125;&amp;#125;&amp;quot;&lt;/span&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;p&amp;gt;Computed reversed message: &lt;span class=&quot;string&quot;&gt;&amp;quot;&amp;#123;&amp;#123; reversedMessage &amp;#125;&amp;#125;&amp;quot;&lt;/span&gt;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  // bad&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;lt;p&amp;gt;&amp;#123;&amp;#123; this.message.split(&lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;#x27;&lt;/span&gt;).reverse().&lt;span class=&quot;built_in&quot;&gt;join&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;#x27;&lt;/span&gt;) &amp;#125;&amp;#125;&amp;lt;/p&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;lt;/div&amp;gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;var vm = new Vue(&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  el: &lt;span class=&quot;string&quot;&gt;&amp;#x27;#example&amp;#x27;&lt;/span&gt;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;data&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      message: &lt;span class=&quot;string&quot;&gt;&amp;#x27;Hello&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;,&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  computed: &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    // 计算属性的 getter&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    reversedMessage: &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;function&lt;/span&gt;&lt;/span&gt; () &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      // `this` 指向 vm 实例&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; this.message.split(&lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;#x27;&lt;/span&gt;).reverse().&lt;span class=&quot;built_in&quot;&gt;join&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&amp;#x27;&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Webpack 打包优化</title>
    <link href="http://yoursite.com/2021/05/15/2021-05-15/"/>
    <id>http://yoursite.com/2021/05/15/2021-05-15/</id>
    <published>2021-05-14T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.325Z</updated>
    
    <content type="html"><![CDATA[<p>async 实现<br>diff算法<br>vue3 setup<br>一键换肤<br>事件委托<br>原型<br>事件循环<br>链表<br>双向绑定<br>promise<br>盒子模型<br>内存泄漏<br>设计模式 发布订阅<br>柯里化<br>webpack 打包优化<br>vue 组件封装<br>跨域<br>vue data()<br>fiber</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;async 实现&lt;br&gt;diff算法&lt;br&gt;vue3 setup&lt;br&gt;一键换肤&lt;br&gt;事件委托&lt;br&gt;原型&lt;br&gt;事件循环&lt;br&gt;链表&lt;br&gt;双向绑定&lt;br&gt;promise&lt;br&gt;盒子模型&lt;br&gt;内存泄漏&lt;br&gt;设计模式 发布订阅&lt;br&gt;柯里化&lt;br&gt;webpack 打包</summary>
      
    
    
    
    <category term="Webpack" scheme="http://yoursite.com/categories/Webpack/"/>
    
    
    <category term="Webpack" scheme="http://yoursite.com/tags/Webpack/"/>
    
  </entry>
  
  <entry>
    <title>React 事件原理</title>
    <link href="http://yoursite.com/2021/04/27/2021-04-27/"/>
    <id>http://yoursite.com/2021/04/27/2021-04-27/</id>
    <published>2021-04-26T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="React-事件原理"><a href="#React-事件原理" class="headerlink" title="React 事件原理"></a>React 事件原理</h1><h2 id="React-事件系统"><a href="#React-事件系统" class="headerlink" title="React 事件系统"></a>React 事件系统</h2><h3 id="事件注册"><a href="#事件注册" class="headerlink" title="事件注册"></a>事件注册</h3><p>初始化形成必要的映射关系</p><h3 id="事件绑定"><a href="#事件绑定" class="headerlink" title="事件绑定"></a>事件绑定</h3><p><code>diffProperties</code> 处理 React 合成事件</p><p><code>legacyListenToEvent</code> 注册事件监听器</p><p>绑定 <code>dispatchEvent</code></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://juejin.cn/post/6909271104440205326"></a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;React-事件原理&quot;&gt;&lt;a href=&quot;#React-事件原理&quot; class=&quot;headerlink&quot; title=&quot;React 事件原理&quot;&gt;&lt;/a&gt;React 事件原理&lt;/h1&gt;&lt;h2 id=&quot;React-事件系统&quot;&gt;&lt;a href=&quot;#React-事件系统&quot;</summary>
      
    
    
    
    <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JS ES6+ 语法新特性</title>
    <link href="http://yoursite.com/2021/03/25/2021-03-25/"/>
    <id>http://yoursite.com/2021/03/25/2021-03-25/</id>
    <published>2021-03-24T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JS-ES6-语法新特性"><a href="#JS-ES6-语法新特性" class="headerlink" title="JS ES6+ 语法新特性"></a>JS ES6+ 语法新特性</h1><p><a href="https://es6.ruanyifeng.com/">ECMAScript 6 入门</a><br>只总结一些常用的 es6+ 用法</p><h2 id="ES6-2015"><a href="#ES6-2015" class="headerlink" title="ES6 (2015)"></a>ES6 (2015)</h2><p>1.类 (class)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class People &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name = name</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">console</span></span>() &#123;</span><br><span class="line">    console.log(this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const man = new People(<span class="string">&#x27;aa&#x27;</span>)</span><br><span class="line">man.console()</span><br></pre></td></tr></table></figure><p>2.模块化 (es module)<br>可以把一个 <code>js</code> 文件当作一个模块</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 模块 A 中导出一个方法</span><br><span class="line"><span class="built_in">export</span> const sumA = (a, b) =&gt; a + b</span><br><span class="line"></span><br><span class="line">// 模块 B 中使用</span><br><span class="line">import &#123; sumA &#125; from <span class="string">&#x27;./A&#x27;</span></span><br><span class="line">console.log(sumA(1, 2))</span><br></pre></td></tr></table></figure><span id="more"></span><p>3.箭头函数 (arrow)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">sum</span> = (a, b) =&gt; a + b</span><br><span class="line"><span class="built_in">sum</span>(a, b)</span><br></pre></td></tr></table></figure><p>4.函数默认值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">sum</span> = (a = 1, b = 2) =&gt; a + b</span><br></pre></td></tr></table></figure><p>5.模版字符串</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const name = <span class="string">&#x27;aa&#x27;</span></span><br><span class="line">const fullName = `my name is <span class="variable">$&#123;name&#125;</span>`</span><br></pre></td></tr></table></figure><p>6.解构赋值</p><p>模式匹配，只要等号两边的模式相同。左边的变量就会被赋予对应的值。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const [, , third] = [1, 2, 3]</span><br><span class="line">third // 3</span><br><span class="line"></span><br><span class="line">const &#123; c &#125; = &#123; a: 1, b: 2, c: 3&#125;</span><br><span class="line">c // 3</span><br></pre></td></tr></table></figure><p>7.对象属性简写</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const name = <span class="string">&#x27;aa&#x27;</span></span><br><span class="line">const obj = &#123; name &#125;</span><br></pre></td></tr></table></figure><p>8.Promise</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Promise.resolve().<span class="keyword">then</span>(() =&gt; &#123; console.log(2) &#125;);</span><br><span class="line">console.log(1)</span><br><span class="line"></span><br><span class="line">// 先打印1，再打印2</span><br></pre></td></tr></table></figure><p>9.let 和 const</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> aa = <span class="string">&#x27;1&#x27;</span></span><br><span class="line">const bb = []</span><br></pre></td></tr></table></figure><h2 id="es7-2016"><a href="#es7-2016" class="headerlink" title="es7 (2016)"></a>es7 (2016)</h2><p>1.includes</p><p>Array.prototype.includes()</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[1].includes(1)</span><br></pre></td></tr></table></figure><p>2.指数操作符</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2**10 // 1024</span><br></pre></td></tr></table></figure><h2 id="es8-2017"><a href="#es8-2017" class="headerlink" title="es8 (2017)"></a>es8 (2017)</h2><p>1.async/await</p><p>异步执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">async <span class="function"><span class="title">getData</span></span>() &#123;</span><br><span class="line">  await res = await api.getThing() // await 异步任务</span><br><span class="line">  // <span class="keyword">do</span> something</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2.Object.values()</p><p>对象中的 values 值</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.values(&#123; a: 1, b: 2, c: 3 &#125;)</span><br><span class="line">// [1, 2, 3]</span><br></pre></td></tr></table></figure><p>3.函数参数列表结尾允许逗号</p><p>4.Object.getOwnPropertyDescriptors</p><p>获取一个对象的所有自身属性的描述符，如果没有属性，则返回 null</p><p>5.SharedArrayBuffer</p><p>用来表示一个通用的，固定长度的原始二进制数据缓冲区</p><p>6.Atomics对象</p><p>提供了一组静态方法用来对 SharedArrayBuffer 对象进行原子操作</p><h2 id="es9-2018"><a href="#es9-2018" class="headerlink" title="es9 (2018)"></a>es9 (2018)</h2><p>1.异步迭代</p><p><code>await</code></p><p>2.Promise.finally()</p><h2 id="es10-2019"><a href="#es10-2019" class="headerlink" title="es10 (2019)"></a>es10 (2019)</h2><p>1.Array.flat()和Array.flatMap()</p><p>2.String.trimStart()和String.trimEnd()</p><h2 id="es11-2020"><a href="#es11-2020" class="headerlink" title="es11 (2020)"></a>es11 (2020)</h2><p>1.Nullish coalescing Operator(空值处理)</p><p>表达式在<code>??</code>的左侧 运算符求值为undefined或null，返回其右侧</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> user = &#123;</span><br><span class="line">u1: 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> u2 = user.u2 ?? <span class="string">&#x27;用户2&#x27;</span> </span><br></pre></td></tr></table></figure><p>2.Optional chaining（可选链）</p><p><code>?.</code>用户检测不确定的中间节点</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> user = &#123;&#125;</span><br><span class="line"><span class="built_in">let</span> u1 = user.childer.name // TypeError: Cannot <span class="built_in">read</span> property <span class="string">&#x27;name&#x27;</span> of undefined</span><br><span class="line"><span class="built_in">let</span> u1 = user.childer?.name // undefined</span><br></pre></td></tr></table></figure><p>3.Promise.allSettled</p><p>返回一个在所有给定的promise已被决议或被拒绝后决议的promise，并带有一个对象数组，每个对象表示对应的promise结果</p><p>4.import()</p><p>按需导入</p><p>5.新基本数据类型BigInt</p><p>任意精度的整数</p><p>6.globalThis</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">浏览器：window</span><br><span class="line">worker：self</span><br><span class="line">node：global</span><br></pre></td></tr></table></figure><p><a href="https://www.zhihu.com/column/p/354901519">参考1</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JS-ES6-语法新特性&quot;&gt;&lt;a href=&quot;#JS-ES6-语法新特性&quot; class=&quot;headerlink&quot; title=&quot;JS ES6+ 语法新特性&quot;&gt;&lt;/a&gt;JS ES6+ 语法新特性&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://es6.ruanyifeng.com/&quot;&gt;ECMAScript 6 入门&lt;/a&gt;&lt;br&gt;只总结一些常用的 es6+ 用法&lt;/p&gt;
&lt;h2 id=&quot;ES6-2015&quot;&gt;&lt;a href=&quot;#ES6-2015&quot; class=&quot;headerlink&quot; title=&quot;ES6 (2015)&quot;&gt;&lt;/a&gt;ES6 (2015)&lt;/h2&gt;&lt;p&gt;1.类 (class)&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;class People &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  constructor(name) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    this.name = name&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;title&quot;&gt;console&lt;/span&gt;&lt;/span&gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    console.log(this.name)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;const man = new People(&lt;span class=&quot;string&quot;&gt;&amp;#x27;aa&amp;#x27;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;man.console()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;2.模块化 (es module)&lt;br&gt;可以把一个 &lt;code&gt;js&lt;/code&gt; 文件当作一个模块&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 模块 A 中导出一个方法&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;built_in&quot;&gt;export&lt;/span&gt; const sumA = (a, b) =&amp;gt; a + b&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 模块 B 中使用&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;import &amp;#123; sumA &amp;#125; from &lt;span class=&quot;string&quot;&gt;&amp;#x27;./A&amp;#x27;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;console.log(sumA(1, 2))&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Promise 深度理解</title>
    <link href="http://yoursite.com/2021/03/17/2021-03-17/"/>
    <id>http://yoursite.com/2021/03/17/2021-03-17/</id>
    <published>2021-03-16T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Promise-深度理解"><a href="#Promise-深度理解" class="headerlink" title="Promise 深度理解"></a>Promise 深度理解</h1><p>在理解 <code>Promise</code> 之前，要先理解什么是异步编程。<code>JavaScript</code> 的异步编程比较特殊，我们一般称之为<strong>单线程异步编程</strong>。</p><h2 id="JS-单线程异步编程"><a href="#JS-单线程异步编程" class="headerlink" title="JS 单线程异步编程"></a>JS 单线程异步编程</h2><h3 id="JS-是单线程的"><a href="#JS-是单线程的" class="headerlink" title="JS 是单线程的"></a>JS 是单线程的</h3><p><code>JavaScript</code> 同时只能处理一件事情。<strong>上面的代码还没执行完成，则无法执行下面的代码。</strong><br><code>JavaScript</code> 中也有部分操作是异步编程。</p><p>但 <code>JavaScript</code> 绝非我们传统编程中的多线程开发，可以同时做多件事情。因为是<strong>单线程处理</strong>，所以如果 <code>JavaScript</code> 引擎正在处理任务，其他任务就不会被处理。</p><p>浏览器基于 <code>EventQueue事件队列</code>, <code>EventLoop事件循环</code> 两大机制，构建出了<strong>异步编程的效果</strong>。</p><h3 id="异步宏任务"><a href="#异步宏任务" class="headerlink" title="异步宏任务"></a>异步宏任务</h3><ol><li>定时器</li><li>DOM 事件</li><li>Http 请求(ajax, fetch, jsonp,…)</li></ol><h3 id="异步微任务"><a href="#异步微任务" class="headerlink" title="异步微任务"></a>异步微任务</h3><ol><li>Promise(resolve, reject, then)</li><li>async await</li><li>requestAnimationFrame</li></ol><span id="more"></span><h3 id="进入异步队列-EventQueue-的查找顺序"><a href="#进入异步队列-EventQueue-的查找顺序" class="headerlink" title="进入异步队列(EventQueue)的查找顺序"></a>进入异步队列(EventQueue)的查找顺序</h3><ol><li>首先去异步微任务队列中查找</li><li>再去异步宏任务队列中查找</li><li>事件循环机制 <code>EventLoop</code><br> 同步任务执行完毕 =&gt; 查找异步队列可执行任务，主线程执行，执行完毕 =&gt; 查找异步队列任务执行</li></ol><h3 id="promise-执行过程"><a href="#promise-执行过程" class="headerlink" title="promise 执行过程"></a>promise 执行过程</h3><p><a href="https://mp.weixin.qq.com/s/RRmr0n4s_nUNjxApDxYlhQ">手写一个 Promise</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;Promise-深度理解&quot;&gt;&lt;a href=&quot;#Promise-深度理解&quot; class=&quot;headerlink&quot; title=&quot;Promise 深度理解&quot;&gt;&lt;/a&gt;Promise 深度理解&lt;/h1&gt;&lt;p&gt;在理解 &lt;code&gt;Promise&lt;/code&gt; 之前，要先理解什么是异步编程。&lt;code&gt;JavaScript&lt;/code&gt; 的异步编程比较特殊，我们一般称之为&lt;strong&gt;单线程异步编程&lt;/strong&gt;。&lt;/p&gt;
&lt;h2 id=&quot;JS-单线程异步编程&quot;&gt;&lt;a href=&quot;#JS-单线程异步编程&quot; class=&quot;headerlink&quot; title=&quot;JS 单线程异步编程&quot;&gt;&lt;/a&gt;JS 单线程异步编程&lt;/h2&gt;&lt;h3 id=&quot;JS-是单线程的&quot;&gt;&lt;a href=&quot;#JS-是单线程的&quot; class=&quot;headerlink&quot; title=&quot;JS 是单线程的&quot;&gt;&lt;/a&gt;JS 是单线程的&lt;/h3&gt;&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt; 同时只能处理一件事情。&lt;strong&gt;上面的代码还没执行完成，则无法执行下面的代码。&lt;/strong&gt;&lt;br&gt;&lt;code&gt;JavaScript&lt;/code&gt; 中也有部分操作是异步编程。&lt;/p&gt;
&lt;p&gt;但 &lt;code&gt;JavaScript&lt;/code&gt; 绝非我们传统编程中的多线程开发，可以同时做多件事情。因为是&lt;strong&gt;单线程处理&lt;/strong&gt;，所以如果 &lt;code&gt;JavaScript&lt;/code&gt; 引擎正在处理任务，其他任务就不会被处理。&lt;/p&gt;
&lt;p&gt;浏览器基于 &lt;code&gt;EventQueue事件队列&lt;/code&gt;, &lt;code&gt;EventLoop事件循环&lt;/code&gt; 两大机制，构建出了&lt;strong&gt;异步编程的效果&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;异步宏任务&quot;&gt;&lt;a href=&quot;#异步宏任务&quot; class=&quot;headerlink&quot; title=&quot;异步宏任务&quot;&gt;&lt;/a&gt;异步宏任务&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;定时器&lt;/li&gt;
&lt;li&gt;DOM 事件&lt;/li&gt;
&lt;li&gt;Http 请求(ajax, fetch, jsonp,…)&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&quot;异步微任务&quot;&gt;&lt;a href=&quot;#异步微任务&quot; class=&quot;headerlink&quot; title=&quot;异步微任务&quot;&gt;&lt;/a&gt;异步微任务&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;Promise(resolve, reject, then)&lt;/li&gt;
&lt;li&gt;async await&lt;/li&gt;
&lt;li&gt;requestAnimationFrame&lt;/li&gt;
&lt;/ol&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript 常用小技巧</title>
    <link href="http://yoursite.com/2021/01/04/2021-01-04/"/>
    <id>http://yoursite.com/2021/01/04/2021-01-04/</id>
    <published>2021-01-03T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JavaScript-常用小技巧"><a href="#JavaScript-常用小技巧" class="headerlink" title="JavaScript 常用小技巧"></a>JavaScript 常用小技巧</h1><h2 id="类型检查小工具"><a href="#类型检查小工具" class="headerlink" title="类型检查小工具"></a>类型检查小工具</h2><p><code>JavaScript</code> 不是强类型语言，我们可以通过集成强类型检测 <code>TypeScript</code>， 但是有时候我们只是想做一个简单的类型检查。这时候就可以用到 <code>typeof</code> 关键字。</p><p><code>typeof</code> 的问题在于，用于基本数据类型和函数时效果很好，但是对于数组和对象来说，由于它们都被视为对象，因此很难把握它们之间的区别。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">const isOfType = (() =&gt; &#123;</span><br><span class="line">  // create a plain object with no prototype</span><br><span class="line">  const <span class="built_in">type</span> = Object.create(null);</span><br><span class="line"></span><br><span class="line">  // check <span class="keyword">for</span> null <span class="built_in">type</span></span><br><span class="line">  type.null = x =&gt; x === null;</span><br><span class="line">  </span><br><span class="line">  type.undefined = x =&gt; x === undefined;</span><br><span class="line">  </span><br><span class="line">  type.nil = x =&gt; type.null(x) || type.undefined(x);</span><br><span class="line"></span><br><span class="line">  type.string = x =&gt; !type.nil(x) &amp;&amp; (typeof x === <span class="string">&#x27;string&#x27;</span> || x instanceof String);</span><br><span class="line">  </span><br><span class="line">  type.number = x =&gt; !type.nil(x) &amp;&amp; ((!isNaN(x) &amp;&amp; isFinite(x) &amp;&amp; typeof x === <span class="string">&#x27;number&#x27;</span>) || x instanceof Number);</span><br><span class="line"></span><br><span class="line">  type.boolean = x =&gt; !type.nil(x) &amp;&amp; (typeof x === <span class="string">&#x27;boolean&#x27;</span> || x instanceof Boolean);</span><br><span class="line"></span><br><span class="line">  type.array = x =&gt; !type.nil(x) &amp;&amp; Array.isArray(x);</span><br><span class="line"></span><br><span class="line">  type.object = x =&gt; (&#123;&#125;).toString.call(x) === <span class="string">&#x27;[object Object]&#x27;</span>;</span><br><span class="line"></span><br><span class="line">  type.type = x =&gt; (x, X) =&gt; !type.nil(x) &amp;&amp; x instanceof X;</span><br><span class="line"></span><br><span class="line">  type.set = x =&gt; type.type(x, Set);</span><br><span class="line"></span><br><span class="line">  type.map = x =&gt; type.type(x, Map);</span><br><span class="line"></span><br><span class="line">  type.date = x =&gt; type.type(x, Date);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">return</span> <span class="built_in">type</span>;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="检查是否为空"><a href="#检查是否为空" class="headerlink" title="检查是否为空"></a>检查是否为空</h2><p>在写代码时，我们需要知道变量是否为空，并且根据结果决定要使用的方法，例如检查长度，大小，或者是否包含任何子元素，可以使用以下方法。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> isEmpty(x) &#123;</span><br><span class="line">  <span class="keyword">if</span> (Array.isArray(x) || typeof x === <span class="string">&#x27;string&#x27;</span> || x instanceof String) &#123;</span><br><span class="line">     <span class="built_in">return</span> x.length === 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (x instanceof Map || x instanceof Set) &#123;</span><br><span class="line">     <span class="built_in">return</span> x.size === 0;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((&#123;&#125;).toString.call(x) === [<span class="string">&#x27;object Object&#x27;</span>]) &#123;</span><br><span class="line">     <span class="built_in">return</span> Object.keys(x).length = 0;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="带有范围的随机数生成器"><a href="#带有范围的随机数生成器" class="headerlink" title="带有范围的随机数生成器"></a>带有范围的随机数生成器</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> randomNumber(max = 1, min = 0) &#123;</span><br><span class="line">  <span class="keyword">if</span> (min &lt; max) &#123;</span><br><span class="line">    <span class="built_in">return</span> max</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> Math.floor(Math.random() * (max - min) + min)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="随机-ID-生成器"><a href="#随机-ID-生成器" class="headerlink" title="随机 ID 生成器"></a>随机 ID 生成器</h2><p>在 react/vue 使用的过程中，前端有时候需要一些 ID，例如 UUID，这个时候我们就需要使用一个 ID 生成器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const uniqueId = (() =&gt; &#123;</span><br><span class="line">  const <span class="built_in">id</span>  = (<span class="keyword">function</span>*() &#123;</span><br><span class="line">    <span class="built_in">let</span> mil = new Date().getTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">      yield mil += 1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)();</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">return</span> () =&gt; id.next().value;</span><br><span class="line">&#125;)()</span><br><span class="line"></span><br><span class="line">console.log(uniqueId())</span><br></pre></td></tr></table></figure><h2 id="顺序执行-promise"><a href="#顺序执行-promise" class="headerlink" title="顺序执行 promise"></a>顺序执行 promise</h2><p>如果有一堆异步或者普通函数都返回 promise, 但是要求一个个执行。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">const asyncSequentializer = (() =&gt; &#123;</span><br><span class="line">  const toPromise = x =&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (x instanceof Promise) &#123;</span><br><span class="line">      <span class="built_in">return</span> x</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (typeof x === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">      <span class="built_in">return</span> (async () =&gt; await())();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">return</span> Promise.resolve(x)</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">return</span> list =&gt; &#123;</span><br><span class="line">    const results = [];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">return</span> list.reduce((lastPromise, currentPromise) =&gt; &#123;</span><br><span class="line">      <span class="built_in">return</span> lastPromise.<span class="keyword">then</span>(res =&gt; &#123;</span><br><span class="line">      results.push(res);</span><br><span class="line">      <span class="built_in">return</span> toPromise(currentPromise);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;, toPromise(list.shift()))</span><br><span class="line">    .<span class="keyword">then</span>(res =&gt; Promise.resolve([...results, res]));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="轮询数据"><a href="#轮询数据" class="headerlink" title="轮询数据"></a>轮询数据</h2><p>如果需要持续的检查数据更新，但是系统中没有 websocket。它非常适合上传文件时，想要持续检查文件是否已完成处理的情况。或者使用第三方 API 并且想要持续检查过程是否完成或骑手是否到达目的地的情况。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">async <span class="keyword">function</span> poll(fn, validate, interval = 2500) &#123;</span><br><span class="line">  const resolver = async (resolve, reject) =&gt; &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      const result = await fn();</span><br><span class="line">      const valid = validate(result);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (valid) &#123;</span><br><span class="line">        resolve(result)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        setTimeout(resolver, interval, resolve, reject);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">      reject(e)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">return</span> new Promise(resolver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="条件对象键"><a href="#条件对象键" class="headerlink" title="条件对象键"></a>条件对象键</h2><p>条件对象键 &amp; 变量作为对象键</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const condition = <span class="literal">true</span></span><br><span class="line">const property = <span class="string">&#x27;newValidProp&#x27;</span></span><br><span class="line"></span><br><span class="line">const man = &#123;</span><br><span class="line">  someProperty: <span class="string">&#x27;some&#x27;</span>,</span><br><span class="line">  ...(condition ? &#123; newProperty: <span class="string">&#x27;value&#x27;</span> &#125; : &#123;&#125;),</span><br><span class="line"></span><br><span class="line">  [`<span class="variable">$&#123;property&#125;</span>`]: value</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除数组重复项"><a href="#删除数组重复项" class="headerlink" title="删除数组重复项"></a>删除数组重复项</h2><p>数组中常有重复的值，可以使用 <code>Set</code> 来消除，适用于多种数据类型。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const numArrays = [1, 2, 3]</span><br><span class="line">const objArrays = [&#123;<span class="built_in">id</span>: 1&#125;, &#123;<span class="built_in">id</span>: 2&#125;]</span><br><span class="line"></span><br><span class="line">Array.from(new Set(objArrays))</span><br></pre></td></tr></table></figure><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://mp.weixin.qq.com/s/IFmzGyz3MWOYj80qrq1Uig">原文</a></p>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;JavaScript-常用小技巧&quot;&gt;&lt;a href=&quot;#JavaScript-常用小技巧&quot; class=&quot;headerlink&quot; title=&quot;JavaScript 常用小技巧&quot;&gt;&lt;/a&gt;JavaScript 常用小技巧&lt;/h1&gt;&lt;h2 id=&quot;类型检查小工具&quot;&gt;&lt;a href=&quot;#类型检查小工具&quot; class=&quot;headerlink&quot; title=&quot;类型检查小工具&quot;&gt;&lt;/a&gt;类型检查小工具&lt;/h2&gt;&lt;p&gt;&lt;code&gt;JavaScript&lt;/code&gt; 不是强类型语言，我们可以通过集成强类型检测 &lt;code&gt;TypeScript&lt;/code&gt;， 但是有时候我们只是想做一个简单的类型检查。这时候就可以用到 &lt;code&gt;typeof&lt;/code&gt; 关键字。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;typeof&lt;/code&gt; 的问题在于，用于基本数据类型和函数时效果很好，但是对于数组和对象来说，由于它们都被视为对象，因此很难把握它们之间的区别。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;30&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;31&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;const isOfType = (() =&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  // create a plain object with no prototype&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  const &lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt; = Object.create(null);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  // check &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; null &lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type.null = x =&amp;gt; x === null;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type.undefined = x =&amp;gt; x === undefined;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type.nil = x =&amp;gt; type.null(x) || type.undefined(x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type.string = x =&amp;gt; !type.nil(x) &amp;amp;&amp;amp; (typeof x === &lt;span class=&quot;string&quot;&gt;&amp;#x27;string&amp;#x27;&lt;/span&gt; || x instanceof String);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type.number = x =&amp;gt; !type.nil(x) &amp;amp;&amp;amp; ((!isNaN(x) &amp;amp;&amp;amp; isFinite(x) &amp;amp;&amp;amp; typeof x === &lt;span class=&quot;string&quot;&gt;&amp;#x27;number&amp;#x27;&lt;/span&gt;) || x instanceof Number);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type.boolean = x =&amp;gt; !type.nil(x) &amp;amp;&amp;amp; (typeof x === &lt;span class=&quot;string&quot;&gt;&amp;#x27;boolean&amp;#x27;&lt;/span&gt; || x instanceof Boolean);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type.array = x =&amp;gt; !type.nil(x) &amp;amp;&amp;amp; Array.isArray(x);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type.object = x =&amp;gt; (&amp;#123;&amp;#125;).toString.call(x) === &lt;span class=&quot;string&quot;&gt;&amp;#x27;[object Object]&amp;#x27;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type.type = x =&amp;gt; (x, X) =&amp;gt; !type.nil(x) &amp;amp;&amp;amp; x instanceof X;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type.set = x =&amp;gt; type.type(x, Set);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type.map = x =&amp;gt; type.type(x, Map);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  type.date = x =&amp;gt; type.type(x, Date);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  &lt;span class=&quot;built_in&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;built_in&quot;&gt;type&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;)()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="http://yoursite.com/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="http://yoursite.com/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>git 连接 github 超时问题</title>
    <link href="http://yoursite.com/2021/01/04/2021-02-18/"/>
    <id>http://yoursite.com/2021/01/04/2021-02-18/</id>
    <published>2021-01-03T16:00:00.000Z</published>
    <updated>2022-10-22T01:34:44.325Z</updated>
    
    <content type="html"><![CDATA[<h1 id="git-连接-github-超时问题"><a href="#git-连接-github-超时问题" class="headerlink" title="git 连接 github 超时问题"></a>git 连接 github 超时问题</h1><h2 id="port-22-报错"><a href="#port-22-报错" class="headerlink" title="port 22 报错"></a>port 22 报错</h2><p>当 git clone 代码的时候遇到 port 22</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh: connect to host github.com port 22: Connection timed out</span><br></pre></td></tr></table></figure><h3 id="找到-git-的安装地址"><a href="#找到-git-的安装地址" class="headerlink" title="找到 git 的安装地址"></a>找到 git 的安装地址</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">// 1.找到 git 安装地址</span><br><span class="line">whereis git</span><br><span class="line"></span><br><span class="line">// 2. 编辑配置</span><br><span class="line">vi /etc/ssh/ssh_config</span><br><span class="line"></span><br><span class="line">// 3.在末尾加入</span><br><span class="line">Host github.com</span><br><span class="line">User git</span><br><span class="line">Hostname ssh.github.com</span><br><span class="line">PreferredAuthentications publickey</span><br><span class="line">IdentityFile ~/.ssh/id_rsa</span><br><span class="line">Port 443</span><br><span class="line"></span><br><span class="line">// 4. 测试 git 是否连接 github 成功</span><br><span class="line">ssh -T git@github.com</span><br><span class="line">// or debugger</span><br><span class="line">ssh -vT git@github.com</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="permision-denied"><a href="#permision-denied" class="headerlink" title="permision denied"></a>permision denied</h2><h3 id="生成密钥"><a href="#生成密钥" class="headerlink" title="生成密钥"></a>生成密钥</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 1. github 账户名</span><br><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;账户名&quot;</span></span><br></pre></td></tr></table></figure><p>以上命令会生成2个文件 <code>~/.ssh/id_rsa</code>, <code>~/.ssh/id_rsa.pub</code></p><h3 id="将-ssh-key-添加到-github"><a href="#将-ssh-key-添加到-github" class="headerlink" title="将 ssh_key 添加到 github"></a>将 ssh_key 添加到 github</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> ~/.ssh/id_rsa.pub</span><br><span class="line"></span><br><span class="line">// 拷贝以上内容</span><br><span class="line">打开 https://github.com/settings/keys =&gt; new ssh keys，添加成功即可</span><br><span class="line"></span><br><span class="line">// 测试是否连接成功</span><br><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure><h2 id="GitHub-does-not-provide-shell-access"><a href="#GitHub-does-not-provide-shell-access" class="headerlink" title="GitHub does not provide shell access"></a>GitHub does not provide shell access</h2><p>解决方法</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br><span class="line"></span><br><span class="line">git remote -v</span><br><span class="line"></span><br><span class="line">git remote set-url origin git@github.com:FateZeros/fate-blog.git</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h1 id=&quot;git-连接-github-超时问题&quot;&gt;&lt;a href=&quot;#git-连接-github-超时问题&quot; class=&quot;headerlink&quot; title=&quot;git 连接 github 超时问题&quot;&gt;&lt;/a&gt;git 连接 github 超时问题&lt;/h1&gt;&lt;h2 id=&quot;port-22-报错&quot;&gt;&lt;a href=&quot;#port-22-报错&quot; class=&quot;headerlink&quot; title=&quot;port 22 报错&quot;&gt;&lt;/a&gt;port 22 报错&lt;/h2&gt;&lt;p&gt;当 git clone 代码的时候遇到 port 22&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;ssh: connect to host github.com port 22: Connection timed out&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h3 id=&quot;找到-git-的安装地址&quot;&gt;&lt;a href=&quot;#找到-git-的安装地址&quot; class=&quot;headerlink&quot; title=&quot;找到 git 的安装地址&quot;&gt;&lt;/a&gt;找到 git 的安装地址&lt;/h3&gt;&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;// 1.找到 git 安装地址&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;whereis git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 2. 编辑配置&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;vi /etc/ssh/ssh_config&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 3.在末尾加入&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Host github.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;User git&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Hostname ssh.github.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;PreferredAuthentications publickey&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;IdentityFile ~/.ssh/id_rsa&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Port 443&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// 4. 测试 git 是否连接 github 成功&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh -T git@github.com&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;// or debugger&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;ssh -vT git@github.com&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="Github" scheme="http://yoursite.com/categories/Github/"/>
    
    
    <category term="Github" scheme="http://yoursite.com/tags/Github/"/>
    
  </entry>
  
</feed>
